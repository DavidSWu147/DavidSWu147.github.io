<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SIMILI - A Dice Game</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Special Elite', 'Courier New', monospace; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script>
const {
  useState,
  useEffect,
  useRef,
  useCallback
} = React;

// ============================================================
// SIMILI - A Dice Game by David Wu
// ============================================================

// --- Constants ---
const TOTAL_ROUNDS = 10;
const MAX_ROWS = 5;
const ROW_SIZE = 4;
const MAX_BOOK_DEFAULT = 3;
const MAX_BOOK_SEQ_BONUS = 4;

// --- Utility Functions ---
function isValidSequence(digits) {
  // Check if digits form a valid ascending or descending sequence (with wrap)
  if (digits.length < 2) return true;
  // Check ascending
  let asc = true;
  for (let i = 1; i < digits.length; i++) {
    if ((digits[i - 1] + 1) % 10 !== digits[i]) {
      asc = false;
      break;
    }
  }
  // Check descending
  let desc = true;
  for (let i = 1; i < digits.length; i++) {
    if ((digits[i - 1] - 1 + 10) % 10 !== digits[i]) {
      desc = false;
      break;
    }
  }
  return asc || desc;
}
function canExtendSequence(existing, newDigit, position) {
  // existing is array of {digit, pos} already in the row (pos = cell index 0-3)
  // Check if placing newDigit at position is consistent with ANY valid ascending 
  // or descending sequence (with wrap) that could fill the 4-cell row.
  const all = [...existing, {
    digit: newDigit,
    pos: position
  }];
  if (all.length < 2) return true;

  // For an ascending sequence starting with value `start` at cell 0:
  //   cell i has value (start + i) % 10
  // For a descending sequence starting with value `start` at cell 0:
  //   cell i has value (start - i + 10) % 10
  // 
  // Check ascending: all placed digits must satisfy digit === (start + pos) % 10
  //   From any placed digit: start = (digit - pos + 10) % 10
  //   All placed digits must agree on the same start value.
  const ascStarts = all.map(({
    digit,
    pos
  }) => (digit - pos + 40) % 10);
  const ascValid = ascStarts.every(s => s === ascStarts[0]);

  // Check descending: all placed digits must satisfy digit === (start - pos + 10) % 10
  //   From any placed digit: start = (digit + pos) % 10
  const descStarts = all.map(({
    digit,
    pos
  }) => (digit + pos) % 10);
  const descValid = descStarts.every(s => s === descStarts[0]);
  return ascValid || descValid;
}
function isValidLadderPlacement(row) {
  // Ladder: cells [0,1] are one pair, cells [2,3] are the other pair.
  // Complete ladder: XXYY where Y = XÂ±1 (wraps 9â†”0).
  // Validate partial placements based on position.
  const a = row[0],
    b = row[1],
    c = row[2],
    d = row[3];

  // Check left pair consistency (cells 0 and 1 must match if both present)
  if (a !== null && b !== null && a !== b) return false;
  // Check right pair consistency (cells 2 and 3 must match if both present)
  if (c !== null && d !== null && c !== d) return false;

  // Get the value of each pair (if any digit is placed)
  const leftVal = a !== null ? a : b; // could be null if neither placed
  const rightVal = c !== null ? c : d;

  // If both pairs have at least one digit, check Â±1 relationship
  if (leftVal !== null && rightVal !== null) {
    const diff = Math.abs(leftVal - rightVal);
    if (diff !== 1 && diff !== 9) return false;
  }
  return true;
}
function isValidLaxLadderPlacement(row) {
  // Lax: digits can go in any cell, but must form a valid XXYY pattern.
  // Validate that all placed digits are consistent with some valid ladder.
  const filled = row.filter(c => c !== null);
  if (filled.length === 0) return true;
  if (filled.length === 1) return true;

  // Get distinct values
  const distinct = [...new Set(filled)];
  if (distinct.length > 2) return false;
  if (distinct.length === 1) {
    // All same digit so far â€” valid if we have at most 2
    if (filled.length > 2) return false;
    return true;
  }

  // Two distinct values â€” check they are adjacent (Â±1 with wrap)
  const diff = Math.abs(distinct[0] - distinct[1]);
  if (diff !== 1 && diff !== 9) return false;

  // Each value can appear at most twice
  const count0 = filled.filter(d => d === distinct[0]).length;
  const count1 = filled.filter(d => d === distinct[1]).length;
  if (count0 > 2 || count1 > 2) return false;
  return true;
}
function scoreLadderRow(cells, laxPlacement = false) {
  const filled = cells.filter(c => c !== null);
  if (filled.length !== 4) return 0;
  if (laxPlacement) {
    // Any arrangement of XXYY where Y = XÂ±1 (wraps 9â†”0)
    const sorted = [...filled].sort((a, b) => a - b);
    // Should have exactly two pairs
    if (sorted[0] === sorted[1] && sorted[2] === sorted[3] && sorted[0] !== sorted[2]) {
      const diff = Math.abs(sorted[0] - sorted[2]);
      if (diff === 1 || diff === 9) return 20;
    }
    return 0;
  }
  return isValidLadderPlacement(cells) ? 20 : 0;
}
function scoreSequenceRow(cells) {
  const filled = cells.filter(c => c !== null);
  if (filled.length >= 4 && isValidSequence(filled)) return 15;
  if (filled.length >= 3) {
    // Check contiguous groups of 3
    const positions = cells.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
    // For 3-sequence, need 3 contiguous filled cells that form a valid sequence
    for (let start = 0; start <= positions.length - 3; start++) {
      const group = positions.slice(start, start + 3);
      if (group[2] - group[0] === 2) {
        // contiguous
        const digits = group.map(i => cells[i]);
        if (isValidSequence(digits)) return 10;
      }
    }
  }
  return 0;
}
function scoreMatchingRow(cells, laxPlacement = false) {
  const filled = cells.filter(c => c !== null);
  if (filled.length === 0) return 0;
  const allSame = filled.every(d => d === filled[0]);
  if (!allSame) return 0;
  if (filled.length >= 4) return 20;
  if (filled.length >= 3) {
    if (laxPlacement) return 15;
    // Strict: need 3 contiguous matching cells
    const positions = cells.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
    for (let start = 0; start <= positions.length - 3; start++) {
      const group = positions.slice(start, start + 3);
      if (group[2] - group[0] === 2) return 15; // contiguous
    }
    return 0;
  }
  return 0;
}
function scoreRow(category, cells, laxPlacement = false) {
  if (category === 'sequence') return scoreSequenceRow(cells);
  if (category === 'matching') return scoreMatchingRow(cells, laxPlacement);
  if (category === 'ladder') return scoreLadderRow(cells, laxPlacement);
  return 0;
}
function totalScore(grids, laxPlacement = false) {
  let total = 0;
  for (const cat of ['sequence', 'matching', 'ladder']) {
    for (const row of grids[cat]) {
      total += scoreRow(cat, row, laxPlacement);
    }
  }
  return total;
}
function hasSequenceBonusI(grids) {
  return grids.sequence.some(row => scoreSequenceRow(row) >= 10);
}
function countCompletedSequences3(grids) {
  return grids.sequence.filter(row => scoreSequenceRow(row) >= 10).length;
}
function countCompletedSequences4(grids) {
  return grids.sequence.filter(row => scoreSequenceRow(row) >= 15).length;
}
function hasSequenceBonusIIA(grids) {
  return countCompletedSequences3(grids) >= 5;
}
function hasSequenceBonusIIB(grids) {
  return countCompletedSequences4(grids) >= 4;
}
function hasSequenceBonusIII(grids) {
  return countCompletedSequences4(grids) >= 5;
}
function hasModernBonusIII(grids, laxPlacement = false) {
  // Modern: any category completely filled with max-scoring rows
  if (countCompletedSequences4(grids) >= 5) return true;
  if (grids.matching.every(row => scoreMatchingRow(row, laxPlacement) >= 20)) return true;
  if (grids.ladder.every(row => scoreLadderRow(row, laxPlacement) >= 20)) return true;
  return false;
}
function allRowsFilled(grids, cat) {
  return grids[cat].every(row => row.every(c => c !== null));
}

// --- Slot Machine Reel Component ---
function SlotReel({
  targetDigit,
  spinning,
  delay = 0,
  onStop
}) {
  const [displayDigit, setDisplayDigit] = useState(0);
  const [isStopped, setIsStopped] = useState(false);
  const intervalRef = useRef(null);
  const timeoutRef = useRef(null);
  useEffect(() => {
    if (targetDigit === null) {
      setIsStopped(false);
    }
  }, [targetDigit]);
  useEffect(() => {
    if (spinning) {
      setIsStopped(false);
      const spinDelay = setTimeout(() => {
        intervalRef.current = setInterval(() => {
          setDisplayDigit(Math.floor(Math.random() * 10));
        }, 60);
      }, delay);
      timeoutRef.current = setTimeout(() => {
        clearInterval(intervalRef.current);
        setDisplayDigit(targetDigit);
        setIsStopped(true);
        if (onStop) onStop();
      }, 1200 + delay);
      return () => {
        clearTimeout(spinDelay);
        clearTimeout(timeoutRef.current);
        clearInterval(intervalRef.current);
      };
    }
  }, [spinning, targetDigit, delay]);
  return /*#__PURE__*/React.createElement("div", {
    style: {
      width: 56,
      height: 72,
      background: isStopped ? '#fff' : '#f5f0e6',
      border: '2px solid #2a2a2a',
      borderRadius: 6,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 36,
      fontWeight: 'bold',
      color: '#2a2a2a',
      boxShadow: spinning && !isStopped ? '0 0 12px rgba(180,140,60,0.4)' : '1px 2px 4px rgba(0,0,0,0.15)',
      transition: 'box-shadow 0.3s, background 0.3s',
      position: 'relative',
      overflow: 'hidden'
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      transition: isStopped ? 'transform 0.15s' : 'none',
      transform: isStopped ? 'scale(1.1)' : 'scale(1)'
    }
  }, spinning || isStopped ? isStopped ? targetDigit : displayDigit : '?'));
}

// --- Bank Display ---
function BankDigit({
  digit,
  used,
  onClick,
  selectable,
  selected
}) {
  return /*#__PURE__*/React.createElement("span", {
    onClick: selectable && !used ? onClick : undefined,
    style: {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: 30,
      height: 32,
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 20,
      color: used ? '#bbb' : selected ? '#c0392b' : '#2a2a2a',
      textDecoration: used ? 'line-through' : 'none',
      cursor: selectable && !used ? 'pointer' : 'default',
      background: selected ? '#fde8e8' : 'transparent',
      border: selected ? '2px solid #c0392b' : '2px solid transparent',
      borderRadius: 4,
      transition: 'all 0.15s',
      fontWeight: selected ? 'bold' : 'normal'
    }
  }, digit);
}

// --- Grid Cell ---
function GridCell({
  value,
  onClick,
  clickable,
  highlight
}) {
  return /*#__PURE__*/React.createElement("div", {
    onClick: clickable ? onClick : undefined,
    style: {
      width: 36,
      height: 36,
      border: '1.5px solid #888',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 20,
      color: '#2a2a2a',
      background: clickable ? '#fffde6' : highlight ? '#e8f5e9' : '#fff',
      cursor: clickable ? 'pointer' : 'default',
      transition: 'background 0.15s'
    }
  }, value !== null ? value : '');
}

// --- Score Track ---
function ScoreTrack({
  score,
  bonusIII
}) {
  const adjustedScore = score + (bonusIII ? 5 : 0);
  const trackNumbers = [];
  for (let i = 0; i <= 90; i += 10) trackNumbers.push(i);
  const trackNumbers2 = [];
  for (let i = 5; i <= 95; i += 10) trackNumbers2.push(i);
  return /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 8
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 4,
      alignItems: 'center',
      marginBottom: 2,
      flexWrap: 'wrap'
    }
  }, trackNumbers.map(n => /*#__PURE__*/React.createElement("span", {
    key: n,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 14,
      color: n < adjustedScore ? '#bbb' : n < adjustedScore + 5 && adjustedScore % 10 >= 5 ? '#bbb' : '#2a2a2a',
      textDecoration: n < adjustedScore ? 'line-through' : 'none',
      minWidth: 26,
      textAlign: 'center'
    }
  }, String(n).padStart(2, '0'))), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 16,
      color: adjustedScore >= 100 ? '#c0392b' : '#ccc',
      position: 'relative',
      top: -0.5
    }
  }, "\uD83D\uDCAF")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 4,
      alignItems: 'center',
      flexWrap: 'wrap'
    }
  }, trackNumbers2.map(n => /*#__PURE__*/React.createElement("span", {
    key: n,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 14,
      color: n < adjustedScore ? '#bbb' : '#2a2a2a',
      textDecoration: n < adjustedScore ? 'line-through' : 'none',
      minWidth: 26,
      textAlign: 'center'
    }
  }, String(n).padStart(2, '0'))), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 14,
      color: '#c0392b',
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontWeight: 'bold',
      minWidth: 26,
      textAlign: 'center',
      position: 'relative',
      top: -1.5,
      marginLeft: -5.5,
      display: 'inline-block',
      transform: adjustedScore >= 105 ? 'none' : 'scale(1.25)',
      transformOrigin: 'center center'
    }
  }, adjustedScore >= 105 ? adjustedScore : adjustedScore > 100 ? `â™¥${adjustedScore - 100}` : 'â™¥')));
}

// --- Toggle Switch Component ---
function ToggleSwitch({
  checked,
  onChange,
  leftLabel,
  rightLabel
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: 8,
      fontSize: 13,
      cursor: 'pointer'
    },
    onClick: () => onChange(!checked)
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      color: !checked ? '#2a2a2a' : '#aaa',
      fontWeight: !checked ? 'bold' : 'normal',
      transition: 'all 0.15s'
    }
  }, leftLabel), /*#__PURE__*/React.createElement("div", {
    style: {
      width: 36,
      height: 20,
      background: checked ? '#2a2a2a' : '#ccc',
      borderRadius: 10,
      position: 'relative',
      transition: 'background 0.2s',
      flexShrink: 0
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      width: 16,
      height: 16,
      background: '#fff',
      borderRadius: '50%',
      position: 'absolute',
      top: 2,
      left: checked ? 18 : 2,
      transition: 'left 0.2s',
      boxShadow: '0 1px 2px rgba(0,0,0,0.2)'
    }
  })), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      color: checked ? '#2a2a2a' : '#aaa',
      fontWeight: checked ? 'bold' : 'normal',
      transition: 'all 0.15s'
    }
  }, rightLabel));
}

// --- Main Game Component ---
function Simili() {
  // Settings
  const [showSettings, setShowSettings] = useState(false);
  const [wideLayout, setWideLayout] = useState(false);
  const [verticalCategories, setVerticalCategories] = useState(false);
  const [twoPlayer, setTwoPlayer] = useState(false);
  const [matchPlay, setMatchPlay] = useState(false);
  const [classicMode, setClassicMode] = useState(false);
  const [laxPlacement, setLaxPlacement] = useState(false);

  // Game state
  const [round, setRound] = useState(0); // 0-indexed, 0-9
  const [phase, setPhase] = useState('pregame'); // 'pregame' | 'choose' | 'rolling' | 'book' | 'gameover'
  const [abandoned, setAbandoned] = useState(false);
  const [chosenCategory, setChosenCategory] = useState(null);
  const [currentRoll, setCurrentRoll] = useState([null, null, null]);
  const [spinning, setSpinning] = useState(false);
  const [reelsStopped, setReelsStopped] = useState(0);

  // Bank: array of { digit, used, round }
  const [bank, setBank] = useState([]);

  // Grids: 5 rows of 4 cells each
  const [grids, setGrids] = useState({
    sequence: Array.from({
      length: MAX_ROWS
    }, () => Array(ROW_SIZE).fill(null)),
    matching: Array.from({
      length: MAX_ROWS
    }, () => Array(ROW_SIZE).fill(null)),
    ladder: Array.from({
      length: MAX_ROWS
    }, () => Array(ROW_SIZE).fill(null))
  });

  // Booking state
  const [selectedBankIndices, setSelectedBankIndices] = useState([]);
  const [bookingTarget, setBookingTarget] = useState(null); // { category, row, col }

  // Sequence Bonus tracking
  const [seqBonusIIAUsed, setSeqBonusIIAUsed] = useState(false);
  const [seqBonusIIBUsed, setSeqBonusIIBUsed] = useState(false);
  const [seqBonusIIAUnlocked, setSeqBonusIIAUnlocked] = useState(false);
  const [seqBonusIIBUnlocked, setSeqBonusIIBUnlocked] = useState(false);
  const [seqBonusIIACategory, setSeqBonusIIACategory] = useState(null); // 'S' or '?'
  const [seqBonusIIBCategory, setSeqBonusIIBCategory] = useState(null);
  const [bonusBookPhase, setBonusBookPhase] = useState(false); // true if in bonus booking
  const [bonusBookSource, setBonusBookSource] = useState(null); // 'A' or 'B'

  // Round history for display
  const [roundHistory, setRoundHistory] = useState([]);

  // Undo stack: each entry captures the state before a booking
  const [undoStack, setUndoStack] = useState([]);

  // Derived state
  const seqBonusI = hasSequenceBonusI(grids);
  const seqBonusIIA = hasSequenceBonusIIA(grids);
  const seqBonusIIB = classicMode ? false : hasSequenceBonusIIB(grids);
  const seqBonusIII = classicMode ? hasSequenceBonusIII(grids) : hasModernBonusIII(grids, laxPlacement);
  const currentScore = totalScore(grids, laxPlacement) + (seqBonusIII ? 5 : 0);

  // maxBooking is locked in at the start of each round's booking phase
  const [maxBooking, setMaxBooking] = useState(MAX_BOOK_DEFAULT);
  const [bookingsThisRound, setBookingsThisRound] = useState(0);

  // Ref to track abandoned state for timeout callbacks
  const abandonedRef = React.useRef(false);
  React.useEffect(() => {
    abandonedRef.current = abandoned;
  }, [abandoned]);

  // Handle rolling
  const handleRoll = () => {
    // Lock in max booking based on state BEFORE this round's roll
    const bonusIActive = hasSequenceBonusI(grids);
    setMaxBooking(chosenCategory === 'sequence' && bonusIActive ? MAX_BOOK_SEQ_BONUS : MAX_BOOK_DEFAULT);
    const roll = [Math.floor(Math.random() * 10), Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)];
    setCurrentRoll(roll);
    setSpinning(true);
    setReelsStopped(0);
    setPhase('rolling');
    setTimeout(() => {
      if (abandonedRef.current) return;
      setSpinning(false);
      setPhase('book');
      setBank(prev => [...prev, ...roll.map(d => ({
        digit: d,
        used: false,
        round
      }))]);
      setRoundHistory(prev => [...prev, {
        category: chosenCategory,
        roll,
        round
      }]);
      setBookingsThisRound(0);
      setUndoStack([]);
    }, 2200);
  };

  // Handle bank selection
  const toggleBankSelection = index => {
    if (bank[index].used) return;
    setSelectedBankIndices(prev => prev.includes(index) ? prev.filter(i => i !== index) : [...prev, index]);
  };

  // Handle booking a digit into a cell
  const handleBookDigit = (category, rowIdx, colIdx) => {
    if (selectedBankIndices.length !== 1) return;
    const bankIdx = selectedBankIndices[0];
    const digit = bank[bankIdx].digit;

    // Validate placement
    const row = grids[category][rowIdx];
    if (row[colIdx] !== null) return;

    // Check booking limits
    const isBonusBook = bonusBookPhase;
    if (!isBonusBook && bookingsThisRound >= maxBooking) return;

    // Validate consistency
    if (category === 'sequence') {
      const existing = row.map((d, i) => d !== null ? {
        digit: d,
        pos: i
      } : null).filter(Boolean);
      if (!canExtendSequence(existing, digit, colIdx)) return;
    } else if (category === 'matching') {
      const existing = row.filter(c => c !== null);
      if (existing.length > 0 && existing[0] !== digit) return;
    } else if (category === 'ladder') {
      const newRow = [...row];
      newRow[colIdx] = digit;
      if (laxPlacement ? !isValidLaxLadderPlacement(newRow) : !isValidLadderPlacement(newRow)) return;
    }

    // Save undo snapshot before applying
    setUndoStack(prev => [...prev, {
      grids: {
        sequence: grids.sequence.map(r => [...r]),
        matching: grids.matching.map(r => [...r]),
        ladder: grids.ladder.map(r => [...r])
      },
      bank: bank.map(b => ({
        ...b
      })),
      bookingsThisRound,
      maxBooking,
      bonusBookPhase,
      bonusBookSource,
      seqBonusIIAUsed,
      seqBonusIIBUsed,
      seqBonusIIAUnlocked,
      seqBonusIIBUnlocked,
      seqBonusIIACategory,
      seqBonusIIBCategory
    }]);

    // Apply booking
    const newGrids = {
      ...grids
    };
    newGrids[category] = grids[category].map((r, ri) => ri === rowIdx ? r.map((c, ci) => ci === colIdx ? digit : c) : [...r]);
    setGrids(newGrids);
    const newBank = bank.map((b, i) => i === bankIdx ? {
      ...b,
      used: true
    } : b);
    setBank(newBank);
    setSelectedBankIndices([]);

    // Check if this booking unlocks any Sequence Bonus II
    if (hasSequenceBonusIIA(newGrids) && !seqBonusIIAUnlocked) setSeqBonusIIAUnlocked(true);
    if (!classicMode && hasSequenceBonusIIB(newGrids) && !seqBonusIIBUnlocked) setSeqBonusIIBUnlocked(true);
    if (isBonusBook) {
      // Determine if this was in sequence or not
      if (bonusBookSource === 'A') {
        setSeqBonusIIAUsed(true);
        setSeqBonusIIACategory(category === 'sequence' ? 'S' : '?');
      } else {
        setSeqBonusIIBUsed(true);
        setSeqBonusIIBCategory(category === 'sequence' ? 'S' : '?');
      }
      setBonusBookPhase(false);
      setBonusBookSource(null);
    } else {
      setBookingsThisRound(prev => prev + 1);
    }
  };

  // Undo last booking
  const handleUndo = () => {
    if (undoStack.length === 0) return;
    const snapshot = undoStack[undoStack.length - 1];
    setGrids(snapshot.grids);
    setBank(snapshot.bank);
    setBookingsThisRound(snapshot.bookingsThisRound);
    setMaxBooking(snapshot.maxBooking);
    setSeqBonusIIAUsed(snapshot.seqBonusIIAUsed);
    setSeqBonusIIBUsed(snapshot.seqBonusIIBUsed);
    setSeqBonusIIAUnlocked(snapshot.seqBonusIIAUnlocked);
    setSeqBonusIIBUnlocked(snapshot.seqBonusIIBUnlocked);
    setSeqBonusIIACategory(snapshot.seqBonusIIACategory);
    setSeqBonusIIBCategory(snapshot.seqBonusIIBCategory);
    setSelectedBankIndices([]);
    // During endgame-bonus, always return to the endgame menu (not back into bonus booking)
    if (phase === 'endgame-bonus') {
      setBonusBookPhase(false);
      setBonusBookSource(null);
    } else {
      setBonusBookPhase(snapshot.bonusBookPhase);
      setBonusBookSource(snapshot.bonusBookSource);
    }
    setUndoStack(prev => prev.slice(0, -1));
  };

  // End round
  const handleEndRound = () => {
    setSelectedBankIndices([]);
    if (round >= TOTAL_ROUNDS - 1) {
      // Check for unused bonus II
      const hasUnusedA = seqBonusIIAUnlocked && !seqBonusIIAUsed;
      const hasUnusedB = seqBonusIIBUnlocked && !seqBonusIIBUsed;
      if (hasUnusedA || hasUnusedB) {
        setPhase('endgame-bonus');
        setUndoStack([]); // Clear round 10 undo stack so only bonus books can be undone
      } else {
        setPhase('gameover');
      }
    } else {
      setRound(prev => prev + 1);
      setPhase('choose');
      setChosenCategory(null);
    }
  };

  // Use bonus book (during round or endgame)
  const handleUseBonusBook = source => {
    setBonusBookPhase(true);
    setBonusBookSource(source);
  };
  const handleEndBonusBook = () => {
    // Cancel back without consuming the bonus
    setBonusBookPhase(false);
    setBonusBookSource(null);
  };
  const handleEndgameBonusDone = () => {
    setPhase('gameover');
  };

  // Reset game
  const handleReset = () => {
    setRound(0);
    setPhase('pregame');
    setChosenCategory(null);
    setCurrentRoll([null, null, null]);
    setSpinning(false);
    setBank([]);
    setGrids({
      sequence: Array.from({
        length: MAX_ROWS
      }, () => Array(ROW_SIZE).fill(null)),
      matching: Array.from({
        length: MAX_ROWS
      }, () => Array(ROW_SIZE).fill(null)),
      ladder: Array.from({
        length: MAX_ROWS
      }, () => Array(ROW_SIZE).fill(null))
    });
    setSelectedBankIndices([]);
    setBookingsThisRound(0);
    setRoundHistory([]);
    setSeqBonusIIAUsed(false);
    setSeqBonusIIBUsed(false);
    setSeqBonusIIAUnlocked(false);
    setSeqBonusIIBUnlocked(false);
    setSeqBonusIIACategory(null);
    setSeqBonusIIBCategory(null);
    setBonusBookPhase(false);
    setBonusBookSource(null);
    setUndoStack([]);
    setMaxBooking(MAX_BOOK_DEFAULT);
    setAbandoned(false);
  };

  // Determine which categories bonus book can go into
  const bonusBookCategories = (() => {
    if (!bonusBookPhase) return ['sequence', 'matching', 'ladder'];
    // If both bonuses unlocked and one used '?', the other must go to sequence
    if (bonusBookSource === 'A') {
      if (seqBonusIIBUsed && seqBonusIIBCategory === '?') return ['sequence'];
      return ['sequence', 'matching', 'ladder'];
    }
    if (bonusBookSource === 'B') {
      if (seqBonusIIAUsed && seqBonusIIACategory === '?') return ['sequence'];
      return ['sequence', 'matching', 'ladder'];
    }
    return ['sequence', 'matching', 'ladder'];
  })();
  const paperBg = '#faf6ed';
  const inkColor = '#2a2a2a';
  const redInk = '#c0392b';
  return /*#__PURE__*/React.createElement("div", {
    style: {
      minHeight: '100vh',
      background: `
        linear-gradient(to bottom, #f0ebe0, #faf6ed 5%, #faf6ed 95%, #f0ebe0)
      `,
      fontFamily: "'Special Elite', 'Courier New', monospace",
      color: inkColor,
      padding: '20px 8px'
    }
  }, /*#__PURE__*/React.createElement("style", null, `
        @import url('https://fonts.googleapis.com/css2?family=Special+Elite&display=swap');
        * { box-sizing: border-box; }
        @keyframes reelSpin {
          0% { transform: translateY(0); }
          25% { transform: translateY(-8px); }
          50% { transform: translateY(0); }
          75% { transform: translateY(8px); }
          100% { transform: translateY(0); }
        }
      `), /*#__PURE__*/React.createElement("div", {
    style: {
      maxWidth: wideLayout ? 1200 : 800,
      margin: '0 auto',
      background: '#fff',
      border: '2px solid #ccc',
      borderRadius: 4,
      padding: '24px 20px',
      boxShadow: '4px 4px 0 #ddd, 2px 2px 0 #e8e4d8',
      position: 'relative'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      position: 'absolute',
      top: 12,
      left: -8,
      width: 16,
      height: 16,
      borderRadius: '50%',
      background: paperBg,
      border: '1px solid #ccc'
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      position: 'absolute',
      top: 12,
      right: -8,
      width: 16,
      height: 16,
      borderRadius: '50%',
      background: paperBg,
      border: '1px solid #ccc'
    }
  }), /*#__PURE__*/React.createElement("h1", {
    style: {
      textAlign: 'center',
      fontSize: 42,
      margin: '0 0 8px',
      letterSpacing: 8,
      fontWeight: 'bold'
    }
  }, /*#__PURE__*/React.createElement("span", null, "S"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: '0.75em'
    }
  }, "I"), /*#__PURE__*/React.createElement("span", null, "M"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: '0.75em'
    }
  }, "I"), /*#__PURE__*/React.createElement("span", null, "L"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: '0.75em'
    }
  }, "I")), /*#__PURE__*/React.createElement("div", {
    style: {
      textAlign: 'center',
      marginBottom: 16
    }
  }, /*#__PURE__*/React.createElement(ScoreTrack, {
    score: totalScore(grids, laxPlacement),
    bonusIII: seqBonusIII
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 16,
      fontWeight: 'bold'
    }
  }, "Score: ", currentScore, " / 100")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      marginBottom: 20,
      padding: '16px 0',
      borderTop: '1px dashed #ccc',
      borderBottom: '1px dashed #ccc'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      marginBottom: 8,
      opacity: 0.7
    }
  }, phase === 'pregame' ? 'Configure settings below, then click Start Game.' : `Round ${round + 1} of ${TOTAL_ROUNDS}`), phase === 'choose' && /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 16
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      marginBottom: 8,
      textAlign: 'center'
    }
  }, "Choose your category:"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 12,
      justifyContent: 'center'
    }
  }, ['sequence', 'matching', 'ladder'].map(cat => /*#__PURE__*/React.createElement("button", {
    key: cat,
    onClick: () => setChosenCategory(prev => prev === cat ? null : cat),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 18,
      padding: '8px 20px',
      background: chosenCategory === cat ? '#2a2a2a' : '#fff',
      color: chosenCategory === cat ? '#fff' : '#2a2a2a',
      border: '2px solid #2a2a2a',
      borderRadius: 4,
      cursor: 'pointer',
      transition: 'all 0.15s'
    }
  }, cat[0].toUpperCase()))), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      textAlign: 'center',
      marginTop: 4,
      opacity: 0.6
    }
  }, chosenCategory ? `${chosenCategory.charAt(0).toUpperCase() + chosenCategory.slice(1)} selected` : 'S = Sequence Â· M = Matching Â· L = Ladder')), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 12,
      marginBottom: 12
    }
  }, [0, 1, 2].map(i => /*#__PURE__*/React.createElement(SlotReel, {
    key: i,
    targetDigit: currentRoll[i],
    spinning: spinning,
    delay: i * 300
  }))), phase === 'choose' && chosenCategory && /*#__PURE__*/React.createElement("button", {
    onClick: handleRoll,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 20,
      padding: '10px 40px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 6,
      cursor: 'pointer',
      letterSpacing: 2,
      transition: 'transform 0.1s'
    },
    onMouseDown: e => e.target.style.transform = 'scale(0.97)',
    onMouseUp: e => e.target.style.transform = 'scale(1)'
  }, "ROLL"), phase === 'rolling' && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 16,
      opacity: 0.6
    }
  }, "Rolling...")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 16,
      flexWrap: 'wrap'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      flex: '0 0 auto'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      fontWeight: 'bold',
      marginBottom: 6
    }
  }, "Bank"), Array.from({
    length: TOTAL_ROUNDS
  }, (_, r) => {
    const roundDigits = bank.filter(b => b.round === r);
    const history = roundHistory[r];
    return /*#__PURE__*/React.createElement("div", {
      key: r,
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 4,
        marginBottom: 2,
        opacity: r > round ? 0.3 : 1
      }
    }, /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 13,
        width: 20,
        textAlign: 'right'
      }
    }, r + 1, "."), /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        width: 14,
        textAlign: 'center',
        textDecoration: history ? 'underline' : 'none',
        fontWeight: history ? 'bold' : 'normal'
      }
    }, history ? history.category[0].toUpperCase() : 'Â·'), /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        gap: 1
      }
    }, roundDigits.length > 0 ? roundDigits.map((b, i) => {
      const globalIdx = bank.indexOf(b);
      return /*#__PURE__*/React.createElement(BankDigit, {
        key: i,
        digit: b.digit,
        used: b.used,
        selected: selectedBankIndices.includes(globalIdx),
        selectable: (phase === 'book' && (bonusBookPhase || bookingsThisRound < maxBooking) || phase === 'endgame-bonus' && bonusBookPhase) && !b.used,
        onClick: () => toggleBankSelection(globalIdx)
      });
    }) : /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        opacity: 0.3,
        lineHeight: '32px'
      }
    }, "\xB7 \xB7 \xB7")));
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 16,
      flex: 1,
      minWidth: 0,
      flexDirection: verticalCategories ? 'column' : 'row'
    }
  }, ['sequence', 'matching', 'ladder'].map(cat => {
    const catLabel = cat.charAt(0).toUpperCase() + cat.slice(1);
    const scoreInfo = cat === 'sequence' ? 'XYZ=10 / WXYZ=15' : cat === 'matching' ? 'XXX=15 / XXXX=20' : 'XXYY=20 (Y=XÂ±1)';
    const canBookHere = phase === 'book' && chosenCategory === cat || bonusBookPhase && bonusBookCategories.includes(cat) || phase === 'endgame-bonus' && bonusBookPhase && bonusBookCategories.includes(cat);
    return /*#__PURE__*/React.createElement("div", {
      key: cat,
      style: {
        flex: 1,
        minWidth: 0
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        marginBottom: 4
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 16,
        fontWeight: 'bold',
        fontStyle: 'italic'
      }
    }, catLabel), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 11,
        opacity: 0.5
      }
    }, scoreInfo)), grids[cat].map((row, rowIdx) => {
      const rowScore = scoreRow(cat, row, laxPlacement);
      // For green highlight: only highlight filled cells that contribute to the score
      const scoringCells = (() => {
        if (rowScore === 0) return new Set();
        if (cat === 'ladder') {
          // All filled cells contribute
          return new Set(row.map((c, i) => c !== null ? i : -1).filter(i => i !== -1));
        }
        if (cat === 'matching') {
          const filled = row.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
          if (rowScore === 20) return new Set(filled); // 4-matching, all contribute
          if (laxPlacement) return new Set(filled); // Lax: all filled contribute for 3-matching
          // Strict 3-matching: find contiguous group of 3
          for (let start = 0; start <= filled.length - 3; start++) {
            const group = filled.slice(start, start + 3);
            if (group[2] - group[0] === 2) return new Set(group);
          }
          return new Set();
        }
        if (cat === 'sequence') {
          // Find which cells are part of the scoring sequence
          const filled = row.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
          if (rowScore === 15 && filled.length === 4) return new Set(filled);
          // For 3-sequence, find the contiguous group of 3 that scores
          for (let start = 0; start <= filled.length - 3; start++) {
            const group = filled.slice(start, start + 3);
            if (group[2] - group[0] === 2) {
              const digits = group.map(i => row[i]);
              if (isValidSequence(digits)) return new Set(group);
            }
          }
          return new Set();
        }
        return new Set();
      })();

      // For yellow clickable: check if the selected digit can actually go here
      const selectedDigit = selectedBankIndices.length === 1 ? bank[selectedBankIndices[0]].digit : null;
      const canPlaceInCell = colIdx => {
        if (!canBookHere || row[colIdx] !== null || selectedDigit === null) return false;
        if (cat === 'sequence') {
          const existing = row.map((d, i) => d !== null ? {
            digit: d,
            pos: i
          } : null).filter(Boolean);
          return canExtendSequence(existing, selectedDigit, colIdx);
        } else if (cat === 'matching') {
          const existing = row.filter(c => c !== null);
          return existing.length === 0 || existing[0] === selectedDigit;
        } else if (cat === 'ladder') {
          const newRow = [...row];
          newRow[colIdx] = selectedDigit;
          return laxPlacement ? isValidLaxLadderPlacement(newRow) : isValidLadderPlacement(newRow);
        }
        return true;
      };
      return /*#__PURE__*/React.createElement("div", {
        key: rowIdx,
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 2,
          marginBottom: 2
        }
      }, row.map((cell, colIdx) => /*#__PURE__*/React.createElement(GridCell, {
        key: colIdx,
        value: cell,
        clickable: canPlaceInCell(colIdx),
        highlight: scoringCells.has(colIdx),
        onClick: () => handleBookDigit(cat, rowIdx, colIdx)
      })), rowScore > 0 && /*#__PURE__*/React.createElement("span", {
        style: {
          fontSize: 13,
          fontWeight: 'bold',
          color: redInk,
          marginLeft: 4
        }
      }, "+", rowScore));
    }));
  }))), phase === 'pregame' && /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      paddingTop: 12,
      marginTop: 8,
      display: 'flex',
      justifyContent: 'center'
    }
  }, /*#__PURE__*/React.createElement("button", {
    onClick: () => {
      setPhase('choose');
      setShowSettings(false);
    },
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 14,
      padding: '6px 20px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 4,
      cursor: 'pointer'
    }
  }, "Start Game")), (phase === 'book' || phase === 'endgame-bonus') && /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      paddingTop: 12,
      marginTop: 8
    }
  }, !bonusBookPhase && phase === 'book' && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 13,
      marginBottom: 8
    }
  }, /*#__PURE__*/React.createElement("strong", null, "Booking into ", chosenCategory?.charAt(0).toUpperCase() + chosenCategory?.slice(1)), ' Â· ', bookingsThisRound, " / ", maxBooking, " booked", ' Â· ', "Select a digit from the bank, then click a cell in the grid."), bonusBookPhase && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 13,
      marginBottom: 8,
      color: redInk
    }
  }, /*#__PURE__*/React.createElement("strong", null, "\uD83C\uDF81 Bonus Book!"), " Place 1 digit into", ' ', bonusBookCategories.length === 3 ? 'any category' : 'Sequence', ". Select a digit, then click a cell.", /*#__PURE__*/React.createElement("button", {
    onClick: handleEndBonusBook,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 12,
      marginLeft: 8,
      padding: '2px 8px',
      background: '#eee',
      border: '1px solid #ccc',
      borderRadius: 3,
      cursor: 'pointer'
    }
  }, "Cancel")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 8,
      flexWrap: 'wrap'
    }
  }, !bonusBookPhase && phase === 'book' && /*#__PURE__*/React.createElement(React.Fragment, null, seqBonusIIAUnlocked && !seqBonusIIAUsed && /*#__PURE__*/React.createElement("button", {
    onClick: () => handleUseBonusBook('A'),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 13,
      padding: '6px 12px',
      background: '#fffde6',
      border: '1.5px solid #b8860b',
      borderRadius: 4,
      cursor: 'pointer',
      color: '#8b6914'
    }
  }, classicMode ? 'Use Seq Bonus II' : 'Use Seq Bonus II-A'), !classicMode && seqBonusIIBUnlocked && !seqBonusIIBUsed && /*#__PURE__*/React.createElement("button", {
    onClick: () => handleUseBonusBook('B'),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 13,
      padding: '6px 12px',
      background: '#fffde6',
      border: '1.5px solid #b8860b',
      borderRadius: 4,
      cursor: 'pointer',
      color: '#8b6914'
    }
  }, "Use Seq Bonus II-B")), !bonusBookPhase && /*#__PURE__*/React.createElement(React.Fragment, null, undoStack.length > 0 && /*#__PURE__*/React.createElement("button", {
    onClick: handleUndo,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 13,
      padding: '6px 14px',
      background: '#fff',
      color: '#888',
      border: '1.5px solid #ccc',
      borderRadius: 4,
      cursor: 'pointer',
      transition: 'all 0.15s'
    },
    onMouseEnter: e => {
      e.target.style.color = '#c0392b';
      e.target.style.borderColor = '#c0392b';
    },
    onMouseLeave: e => {
      e.target.style.color = '#888';
      e.target.style.borderColor = '#ccc';
    }
  }, "\u21A9 Undo"), /*#__PURE__*/React.createElement("button", {
    onClick: phase === 'endgame-bonus' ? handleEndgameBonusDone : handleEndRound,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 14,
      padding: '6px 20px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 4,
      cursor: 'pointer',
      marginLeft: 'auto'
    }
  }, phase === 'endgame-bonus' ? 'Finish Game' : round >= TOTAL_ROUNDS - 1 ? 'End Game' : 'End Round')))), phase === 'endgame-bonus' && !bonusBookPhase && (() => {
    const anyUnused = seqBonusIIAUnlocked && !seqBonusIIAUsed || seqBonusIIBUnlocked && !seqBonusIIBUsed;
    return /*#__PURE__*/React.createElement("div", {
      style: {
        padding: 12,
        marginTop: 8,
        background: '#fffde6',
        border: '1.5px solid #b8860b',
        borderRadius: 6
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 14,
        fontWeight: 'bold',
        color: '#8b6914',
        marginBottom: 6
      }
    }, anyUnused ? 'End of Game â€” Use remaining Sequence Bonuses!' : 'All Sequence Bonuses used!'), /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        gap: 8,
        alignItems: 'center'
      }
    }, seqBonusIIAUnlocked && !seqBonusIIAUsed && /*#__PURE__*/React.createElement("button", {
      onClick: () => handleUseBonusBook('A'),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '6px 12px',
        background: '#fff',
        border: '1.5px solid #b8860b',
        borderRadius: 4,
        cursor: 'pointer'
      }
    }, classicMode ? 'Use Bonus II' : 'Use Bonus II-A'), !classicMode && seqBonusIIBUnlocked && !seqBonusIIBUsed && /*#__PURE__*/React.createElement("button", {
      onClick: () => handleUseBonusBook('B'),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '6px 12px',
        background: '#fff',
        border: '1.5px solid #b8860b',
        borderRadius: 4,
        cursor: 'pointer'
      }
    }, "Use Bonus II-B"), undoStack.length > 0 && /*#__PURE__*/React.createElement("button", {
      onClick: handleUndo,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '6px 14px',
        background: '#fff',
        color: '#888',
        border: '1.5px solid #ccc',
        borderRadius: 4,
        cursor: 'pointer'
      },
      onMouseEnter: e => {
        e.target.style.color = '#c0392b';
        e.target.style.borderColor = '#c0392b';
      },
      onMouseLeave: e => {
        e.target.style.color = '#888';
        e.target.style.borderColor = '#ccc';
      }
    }, "\u21A9 Undo"), /*#__PURE__*/React.createElement("button", {
      onClick: handleEndgameBonusDone,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '6px 16px',
        background: '#2a2a2a',
        color: '#fff',
        border: 'none',
        borderRadius: 4,
        cursor: 'pointer',
        marginLeft: 'auto'
      }
    }, anyUnused ? 'Skip & Finish' : 'Finish Game')));
  })(), /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      paddingTop: 10,
      marginTop: 12,
      fontSize: 12,
      opacity: 0.7
    }
  }, /*#__PURE__*/React.createElement("strong", null, "Sequence Bonus:"), ' ', /*#__PURE__*/React.createElement("span", {
    style: {
      color: seqBonusI ? '#27ae60' : '#999'
    }
  }, "I ", seqBonusI ? 'âœ“' : 'â—‹'), ' Â· ', classicMode ? /*#__PURE__*/React.createElement("span", {
    style: {
      color: seqBonusIIAUnlocked ? '#27ae60' : '#999'
    }
  }, "II ", seqBonusIIAUnlocked ? seqBonusIIAUsed ? `âœ“(${seqBonusIIACategory})` : 'â˜…' : 'â—‹') : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
    style: {
      color: seqBonusIIAUnlocked ? '#27ae60' : '#999'
    }
  }, "II-A ", seqBonusIIAUnlocked ? seqBonusIIAUsed ? `âœ“(${seqBonusIIACategory})` : 'â˜…' : 'â—‹'), ' Â· ', /*#__PURE__*/React.createElement("span", {
    style: {
      color: seqBonusIIBUnlocked ? '#27ae60' : '#999'
    }
  }, "II-B ", seqBonusIIBUnlocked ? seqBonusIIBUsed ? `âœ“(${seqBonusIIBCategory})` : 'â˜…' : 'â—‹')), ' Â· ', /*#__PURE__*/React.createElement("span", {
    style: {
      color: seqBonusIII ? '#27ae60' : '#999'
    }
  }, "III ", seqBonusIII ? 'âœ“ (+5)' : 'â—‹')), phase === 'gameover' && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 20,
      padding: 24,
      textAlign: 'center',
      background: !abandoned && currentScore >= 100 ? '#e8f5e9' : '#ffeaa7',
      border: `2px solid ${!abandoned && currentScore >= 100 ? '#27ae60' : '#f39c12'}`,
      borderRadius: 8
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 28,
      fontWeight: 'bold',
      marginBottom: 8
    }
  }, !abandoned && currentScore >= 100 ? 'ðŸŽ‰ YOU WIN!' : 'Game Over'), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 20,
      marginBottom: 4
    }
  }, abandoned ? 'Game was Abandoned' : /*#__PURE__*/React.createElement(React.Fragment, null, "Final Score: ", currentScore, currentScore > 100 && /*#__PURE__*/React.createElement("span", {
    style: {
      color: redInk
    }
  }, " (\u2665", currentScore - 100, ")"))), /*#__PURE__*/React.createElement("button", {
    onClick: handleReset,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 18,
      padding: '10px 32px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 6,
      cursor: 'pointer',
      marginTop: 16,
      letterSpacing: 2
    }
  }, "PLAY AGAIN")), /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      marginTop: 12,
      paddingTop: 10,
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
    }
  }, (() => {
    const gameActive = phase !== 'pregame' && phase !== 'gameover';
    const abandonEnabled = gameActive;
    return /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        gap: 8,
        alignItems: 'center',
        justifyContent: 'center'
      }
    }, /*#__PURE__*/React.createElement("button", {
      onClick: () => {},
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '4px 0',
        width: 135,
        background: '#fff',
        color: '#888',
        border: '1.5px solid #999',
        borderRadius: 4,
        cursor: 'pointer',
        transition: 'all 0.15s'
      }
    }, "? How to Play"), /*#__PURE__*/React.createElement("button", {
      onClick: () => setShowSettings(prev => !prev),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '4px 0',
        width: 135,
        background: showSettings ? '#2a2a2a' : '#fff',
        color: showSettings ? '#fff' : '#888',
        border: `1.5px solid ${showSettings ? '#2a2a2a' : '#999'}`,
        borderRadius: 4,
        cursor: 'pointer',
        transition: 'all 0.15s'
      }
    }, "\u2699 Settings"), /*#__PURE__*/React.createElement("button", {
      onClick: abandonEnabled ? () => {
        setAbandoned(true);
        setPhase('gameover');
        setSpinning(false);
      } : undefined,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '4px 0',
        width: 135,
        background: '#fff',
        color: abandonEnabled ? redInk : '#ccc',
        border: `1.5px solid ${abandonEnabled ? redInk : '#ddd'}`,
        borderRadius: 4,
        cursor: abandonEnabled ? 'pointer' : 'default',
        transition: 'all 0.15s',
        opacity: abandonEnabled ? 1 : 0.5
      }
    }, "\u2715 Abandon Game"));
  })(), showSettings && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8,
      padding: '12px 16px',
      background: '#faf6ed',
      border: '1px solid #ddd',
      borderRadius: 6,
      width: '100%',
      maxWidth: 400
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      fontWeight: 'bold',
      opacity: 0.5,
      marginBottom: 6,
      textTransform: 'uppercase',
      letterSpacing: 1
    }
  }, "Display"), /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: wideLayout,
    onChange: setWideLayout,
    leftLabel: "Narrow (mobile)",
    rightLabel: "Wide (desktop)"
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: verticalCategories,
    onChange: setVerticalCategories,
    leftLabel: "Side by side",
    rightLabel: "Stacked"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      fontWeight: 'bold',
      opacity: 0.5,
      marginBottom: 6,
      marginTop: 14,
      textTransform: 'uppercase',
      letterSpacing: 1,
      borderTop: '1px dashed #ddd',
      paddingTop: 10
    }
  }, "Gameplay ", phase !== 'pregame' && /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 'normal',
      textTransform: 'none',
      letterSpacing: 0,
      fontStyle: 'italic'
    }
  }, "\u2014 start a new game to change")), /*#__PURE__*/React.createElement("div", {
    style: {
      opacity: phase === 'pregame' ? 1 : 0.4,
      pointerEvents: phase === 'pregame' ? 'auto' : 'none'
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: twoPlayer,
    onChange: setTwoPlayer,
    leftLabel: "1 Player",
    rightLabel: "2 Players"
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: matchPlay,
    onChange: setMatchPlay,
    leftLabel: "Single Game",
    rightLabel: "Match Play"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: classicMode,
    onChange: setClassicMode,
    leftLabel: "Modern",
    rightLabel: "Classic"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: laxPlacement,
    onChange: setLaxPlacement,
    leftLabel: "Strict placement",
    rightLabel: "Lax placement"
  })))))));
}

// Mount the app
ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(Simili));
  </script>
</body>
</html>
