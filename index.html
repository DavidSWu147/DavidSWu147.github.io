<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SIMILI - A Dice Game</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
</head>
<body style="margin: 0; padding: 0;">
  <div id="root"></div>
  <script>const { useState, useEffect, useRef, useCallback } = React;</script>
  <script>
// ============================================================
// SIMILI - A Dice Game by David Wu
// ============================================================

// --- Constants ---
const TOTAL_ROUNDS = 10;
const MAX_ROWS = 5;
const ROW_SIZE = 4;
const MAX_BOOK_DEFAULT = 3;
const MAX_BOOK_SEQ_BONUS = 4;
const MATCH_GAMES = 4;

// --- Utility Functions ---
function isValidSequence(digits) {
  if (digits.length < 2) return true;
  let asc = true;
  for (let i = 1; i < digits.length; i++) {
    if ((digits[i - 1] + 1) % 10 !== digits[i]) {
      asc = false;
      break;
    }
  }
  let desc = true;
  for (let i = 1; i < digits.length; i++) {
    if ((digits[i - 1] - 1 + 10) % 10 !== digits[i]) {
      desc = false;
      break;
    }
  }
  return asc || desc;
}
function canExtendSequence(existing, newDigit, position) {
  const all = [...existing, {
    digit: newDigit,
    pos: position
  }];
  if (all.length < 2) return true;
  const ascStarts = all.map(({
    digit,
    pos
  }) => (digit - pos + 40) % 10);
  const ascValid = ascStarts.every(s => s === ascStarts[0]);
  const descStarts = all.map(({
    digit,
    pos
  }) => (digit + pos) % 10);
  const descValid = descStarts.every(s => s === descStarts[0]);
  return ascValid || descValid;
}
function isValidLadderPlacement(row) {
  const a = row[0],
    b = row[1],
    c = row[2],
    d = row[3];
  if (a !== null && b !== null && a !== b) return false;
  if (c !== null && d !== null && c !== d) return false;
  const leftVal = a !== null ? a : b;
  const rightVal = c !== null ? c : d;
  if (leftVal !== null && rightVal !== null) {
    const diff = Math.abs(leftVal - rightVal);
    if (diff !== 1 && diff !== 9) return false;
  }
  return true;
}
function isValidLaxLadderPlacement(row) {
  const filled = row.filter(c => c !== null);
  if (filled.length === 0) return true;
  if (filled.length === 1) return true;
  const distinct = [...new Set(filled)];
  if (distinct.length > 2) return false;
  if (distinct.length === 1) {
    if (filled.length > 2) return false;
    return true;
  }
  const diff = Math.abs(distinct[0] - distinct[1]);
  if (diff !== 1 && diff !== 9) return false;
  const count0 = filled.filter(d => d === distinct[0]).length;
  const count1 = filled.filter(d => d === distinct[1]).length;
  if (count0 > 2 || count1 > 2) return false;
  return true;
}
function scoreLadderRow(cells, laxPlacement = false) {
  const filled = cells.filter(c => c !== null);
  if (filled.length !== 4) return 0;
  if (laxPlacement) {
    const sorted = [...filled].sort((a, b) => a - b);
    if (sorted[0] === sorted[1] && sorted[2] === sorted[3] && sorted[0] !== sorted[2]) {
      const diff = Math.abs(sorted[0] - sorted[2]);
      if (diff === 1 || diff === 9) return 20;
    }
    return 0;
  }
  return isValidLadderPlacement(cells) ? 20 : 0;
}
function scoreSequenceRow(cells) {
  const filled = cells.filter(c => c !== null);
  if (filled.length >= 4 && isValidSequence(filled)) return 15;
  if (filled.length >= 3) {
    const positions = cells.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
    for (let start = 0; start <= positions.length - 3; start++) {
      const group = positions.slice(start, start + 3);
      if (group[2] - group[0] === 2) {
        const digits = group.map(i => cells[i]);
        if (isValidSequence(digits)) return 10;
      }
    }
  }
  return 0;
}
function scoreMatchingRow(cells, laxPlacement = false) {
  const filled = cells.filter(c => c !== null);
  if (filled.length === 0) return 0;
  const allSame = filled.every(d => d === filled[0]);
  if (!allSame) return 0;
  if (filled.length >= 4) return 20;
  if (filled.length >= 3) {
    if (laxPlacement) return 15;
    const positions = cells.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
    for (let start = 0; start <= positions.length - 3; start++) {
      const group = positions.slice(start, start + 3);
      if (group[2] - group[0] === 2) return 15;
    }
    return 0;
  }
  return 0;
}
function scoreRow(category, cells, laxPlacement = false) {
  if (category === 'sequence') return scoreSequenceRow(cells);
  if (category === 'matching') return scoreMatchingRow(cells, laxPlacement);
  if (category === 'ladder') return scoreLadderRow(cells, laxPlacement);
  return 0;
}
function totalScore(grids, laxPlacement = false) {
  let total = 0;
  for (const cat of ['sequence', 'matching', 'ladder']) {
    for (const row of grids[cat]) {
      total += scoreRow(cat, row, laxPlacement);
    }
  }
  return total;
}
function hasSequenceBonusI(grids) {
  return grids.sequence.some(row => scoreSequenceRow(row) >= 10);
}
function countCompletedSequences3(grids) {
  return grids.sequence.filter(row => scoreSequenceRow(row) >= 10).length;
}
function countCompletedSequences4(grids) {
  return grids.sequence.filter(row => scoreSequenceRow(row) >= 15).length;
}
function hasSequenceBonusIIA(grids) {
  return countCompletedSequences3(grids) >= 5;
}
function hasSequenceBonusIIB(grids) {
  return countCompletedSequences4(grids) >= 4;
}
function hasSequenceBonusIII(grids) {
  return countCompletedSequences4(grids) >= 5;
}
function hasModernBonusIII(grids, laxPlacement = false) {
  if (countCompletedSequences4(grids) >= 5) return true;
  if (grids.matching.every(row => scoreMatchingRow(row, laxPlacement) >= 20)) return true;
  if (grids.ladder.every(row => scoreLadderRow(row, laxPlacement) >= 20)) return true;
  return false;
}

// --- Cell Hint Calculations ---
function getSequenceHints(row) {
  const hints = [null, null, null, null];
  const filled = row.map((c, i) => c !== null ? {
    digit: c,
    pos: i
  } : null).filter(Boolean);
  if (filled.length === 0 || filled.length === 4) return hints;
  for (let colIdx = 0; colIdx < 4; colIdx++) {
    if (row[colIdx] !== null) continue;
    const candidates = [];
    for (let d = 0; d <= 9; d++) {
      if (canExtendSequence(filled, d, colIdx)) candidates.push(d);
    }
    if (candidates.length > 0) hints[colIdx] = candidates;
  }
  return hints;
}
function getMatchingHints(row) {
  const hints = [null, null, null, null];
  const filled = row.filter(c => c !== null);
  if (filled.length === 0 || filled.length === 4) return hints;
  const target = filled[0];
  for (let colIdx = 0; colIdx < 4; colIdx++) {
    if (row[colIdx] !== null) continue;
    hints[colIdx] = [target];
  }
  return hints;
}
function getLadderHints(row, laxPlacement) {
  const hints = [null, null, null, null];
  const filled = row.filter(c => c !== null);
  if (filled.length === 0 || filled.length === 4) return hints;
  for (let colIdx = 0; colIdx < 4; colIdx++) {
    if (row[colIdx] !== null) continue;
    const candidates = [];
    for (let d = 0; d <= 9; d++) {
      const newRow = [...row];
      newRow[colIdx] = d;
      if (laxPlacement ? isValidLaxLadderPlacement(newRow) : isValidLadderPlacement(newRow)) candidates.push(d);
    }
    if (candidates.length > 0) hints[colIdx] = candidates;
  }
  return hints;
}
function getCellHints(category, row, laxPlacement) {
  if (category === 'sequence') return getSequenceHints(row);
  if (category === 'matching') return getMatchingHints(row);
  if (category === 'ladder') return getLadderHints(row, laxPlacement);
  return [null, null, null, null];
}

// --- Unwinnable Detection ---
function isUnwinnableSequence(bank) {
  if (bank.length !== 30) return false;
  const counts = Array(10).fill(0);
  for (const b of bank) counts[b.digit]++;
  const distinct = counts.filter(c => c > 0).length;
  if (distinct === 5) {
    const evens = [0, 2, 4, 6, 8];
    const odds = [1, 3, 5, 7, 9];
    const allEven = evens.every(d => counts[d] > 0) && odds.every(d => counts[d] === 0);
    const allOdd = odds.every(d => counts[d] > 0) && evens.every(d => counts[d] === 0);
    if (allEven || allOdd) {
      const vals = (allEven ? evens : odds).map(d => counts[d]);
      const mod4 = vals.map(v => v % 4);
      if (mod4.filter(m => m === 3).length === 4 && mod4.filter(m => m === 2).length === 1) return true;
    }
  }
  if (distinct === 6) {
    const unwinnablePatterns = [[0, 1, 3, 4, 6, 8], [0, 1, 3, 5, 6, 8], [0, 1, 3, 5, 7, 8], [0, 2, 3, 5, 6, 8], [0, 2, 3, 5, 7, 8], [0, 2, 3, 5, 7, 9], [0, 2, 4, 5, 7, 8], [0, 2, 4, 5, 7, 9], [0, 2, 4, 6, 7, 9], [1, 2, 4, 5, 7, 9], [1, 2, 4, 6, 7, 9], [1, 2, 4, 6, 8, 9], [1, 3, 4, 6, 7, 9], [1, 3, 4, 6, 8, 9], [1, 3, 5, 6, 8, 9]];
    const presentDigits = [];
    for (let d = 0; d < 10; d++) if (counts[d] > 0) presentDigits.push(d);
    for (const pattern of unwinnablePatterns) {
      if (pattern.length !== presentDigits.length) continue;
      if (!pattern.every((d, i) => d === presentDigits[i])) continue;
      const adjacentPairs = [];
      for (let i = 0; i < pattern.length; i++) for (let j = i + 1; j < pattern.length; j++) {
        const diff = Math.abs(pattern[i] - pattern[j]);
        if (diff === 1 || diff === 9) adjacentPairs.push([pattern[i], pattern[j]]);
      }
      let laddersBlocked = true;
      for (const [a, b] of adjacentPairs) {
        const aSingle = counts[a] === 1,
          bSingle = counts[b] === 1;
        if (!(aSingle && !bSingle || !aSingle && bSingle)) {
          laddersBlocked = false;
          break;
        }
      }
      if (!laddersBlocked) continue;
      const nonSingletons = pattern.filter(d => counts[d] > 1);
      if (nonSingletons.length !== 4) continue;
      if (nonSingletons.every(d => counts[d] % 4 === 3)) return true;
    }
  }
  return false;
}

// --- Helper: Create fresh player state ---
function createPlayerState() {
  return {
    grids: {
      sequence: Array.from({
        length: MAX_ROWS
      }, () => Array(ROW_SIZE).fill(null)),
      matching: Array.from({
        length: MAX_ROWS
      }, () => Array(ROW_SIZE).fill(null)),
      ladder: Array.from({
        length: MAX_ROWS
      }, () => Array(ROW_SIZE).fill(null))
    },
    bankUsed: [],
    selectedBankIndices: [],
    chosenCategory: null,
    bookingsThisRound: 0,
    maxBooking: MAX_BOOK_DEFAULT,
    seqBonusIIAUsed: false,
    seqBonusIIBUsed: false,
    seqBonusIIAUnlocked: false,
    seqBonusIIBUnlocked: false,
    seqBonusIIACategory: null,
    seqBonusIIBCategory: null,
    bonusBookPhase: false,
    bonusBookSource: null,
    undoStack: [],
    roundDone: false
  };
}
function getPlayerFinalScore(ps, classicMode, laxPlacement) {
  const grids = ps.grids;
  const seqBonusIII = classicMode ? hasSequenceBonusIII(grids) : hasModernBonusIII(grids, laxPlacement);
  return totalScore(grids, laxPlacement) + (seqBonusIII ? 5 : 0);
}

// --- Slot Machine Reel Component ---
function SlotReel({
  targetDigit,
  spinning,
  delay = 0,
  onStop
}) {
  const [displayDigit, setDisplayDigit] = useState(0);
  const [isStopped, setIsStopped] = useState(false);
  const intervalRef = useRef(null);
  const timeoutRef = useRef(null);
  useEffect(() => {
    if (targetDigit === null) setIsStopped(false);
  }, [targetDigit]);
  useEffect(() => {
    if (spinning) {
      setIsStopped(false);
      const spinDelay = setTimeout(() => {
        intervalRef.current = setInterval(() => {
          setDisplayDigit(Math.floor(Math.random() * 10));
        }, 60);
      }, delay);
      timeoutRef.current = setTimeout(() => {
        clearInterval(intervalRef.current);
        setDisplayDigit(targetDigit);
        setIsStopped(true);
        if (onStop) onStop();
      }, 1200 + delay);
      return () => {
        clearTimeout(spinDelay);
        clearTimeout(timeoutRef.current);
        clearInterval(intervalRef.current);
      };
    }
  }, [spinning, targetDigit, delay]);
  return /*#__PURE__*/React.createElement("div", {
    style: {
      width: 56,
      height: 72,
      background: isStopped ? '#fff' : '#f5f0e6',
      border: '2px solid #2a2a2a',
      borderRadius: 6,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 36,
      fontWeight: 'bold',
      color: '#2a2a2a',
      boxShadow: spinning && !isStopped ? '0 0 12px rgba(180,140,60,0.4)' : '1px 2px 4px rgba(0,0,0,0.15)',
      transition: 'box-shadow 0.3s, background 0.3s',
      position: 'relative',
      overflow: 'hidden'
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      transition: isStopped ? 'transform 0.15s' : 'none',
      transform: isStopped ? 'scale(1.1)' : 'scale(1)'
    }
  }, spinning || isStopped ? isStopped ? targetDigit : displayDigit : '?'));
}

// --- Bank Digit ---
function BankDigit({
  digit,
  used,
  onClick,
  selectable,
  selected,
  crossOut
}) {
  return /*#__PURE__*/React.createElement("span", {
    onClick: selectable && !used ? onClick : undefined,
    style: {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: 30,
      height: 32,
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 20,
      color: used ? '#bbb' : selected ? '#c0392b' : '#2a2a2a',
      textDecoration: used && !crossOut ? 'line-through' : 'none',
      cursor: selectable && !used ? 'pointer' : 'default',
      background: selected ? '#fde8e8' : 'transparent',
      border: selected ? '2px solid #c0392b' : '2px solid transparent',
      borderRadius: 4,
      transition: 'all 0.15s',
      fontWeight: selected ? 'bold' : 'normal',
      position: 'relative'
    }
  }, digit, used && crossOut && /*#__PURE__*/React.createElement("span", {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontSize: 26,
      color: '#bbb',
      pointerEvents: 'none',
      lineHeight: 1
    }
  }, "\u2715"));
}

// --- Grid Cell ---
function GridCell({
  value,
  onClick,
  clickable,
  highlight,
  hints
}) {
  return /*#__PURE__*/React.createElement("div", {
    onClick: clickable ? onClick : undefined,
    style: {
      width: 36,
      height: 36,
      border: '1.5px solid #888',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 20,
      color: '#2a2a2a',
      background: clickable ? '#fffde6' : highlight ? '#e8f5e9' : '#fff',
      cursor: clickable ? 'pointer' : 'default',
      transition: 'background 0.15s',
      position: 'relative'
    }
  }, value !== null ? value : '', value === null && hints && hints.length > 0 && /*#__PURE__*/React.createElement("div", {
    style: {
      position: 'absolute',
      top: 1,
      left: 0,
      right: 0,
      display: 'flex',
      justifyContent: hints.length === 1 ? 'center' : 'space-between',
      padding: '0 3px',
      fontSize: 11,
      color: '#999',
      fontWeight: 'normal',
      lineHeight: '12px',
      pointerEvents: 'none'
    }
  }, hints.sort((a, b) => a - b).map((d, i) => /*#__PURE__*/React.createElement("span", {
    key: i
  }, d))));
}

// --- Score Track ---
function ScoreTrack({
  score,
  bonusIII,
  crossOut
}) {
  const adjustedScore = score + (bonusIII ? 5 : 0);
  const trackNumbers = [];
  for (let i = 0; i <= 90; i += 10) trackNumbers.push(i);
  const trackNumbers2 = [];
  for (let i = 5; i <= 95; i += 10) trackNumbers2.push(i);
  const passedStyle = n => ({
    fontFamily: "'Special Elite', 'Courier New', monospace",
    fontSize: 14,
    color: n < adjustedScore ? '#bbb' : '#2a2a2a',
    textDecoration: n < adjustedScore && !crossOut ? 'line-through' : 'none',
    minWidth: 26,
    textAlign: 'center',
    position: 'relative',
    display: 'inline-block'
  });
  const xOverlay = /*#__PURE__*/React.createElement("span", {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontSize: 26,
      color: '#bbb',
      pointerEvents: 'none',
      lineHeight: 1
    }
  }, "\u2715");
  return /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 8
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 4,
      alignItems: 'center',
      marginBottom: 2,
      flexWrap: 'wrap'
    }
  }, trackNumbers.map(n => /*#__PURE__*/React.createElement("span", {
    key: n,
    style: {
      ...passedStyle(n),
      color: n < adjustedScore ? '#bbb' : n < adjustedScore + 5 && adjustedScore % 10 >= 5 ? '#bbb' : '#2a2a2a'
    }
  }, String(n).padStart(2, '0'), n < adjustedScore && crossOut && xOverlay)), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 16,
      color: adjustedScore >= 100 ? '#c0392b' : '#ccc',
      position: 'relative',
      top: -0.5
    }
  }, "\uD83D\uDCAF")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 4,
      alignItems: 'center',
      flexWrap: 'wrap'
    }
  }, trackNumbers2.map(n => /*#__PURE__*/React.createElement("span", {
    key: n,
    style: passedStyle(n)
  }, String(n).padStart(2, '0'), n < adjustedScore && crossOut && xOverlay)), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 14,
      color: '#c0392b',
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontWeight: adjustedScore > 100 ? 'normal' : 'bold',
      minWidth: 26,
      textAlign: 'center',
      position: 'relative',
      top: -1.5,
      marginLeft: -5.5,
      display: 'inline-block',
      transform: adjustedScore > 100 ? 'none' : 'scale(1.25)',
      transformOrigin: 'center center'
    }
  }, adjustedScore > 100 ? adjustedScore : '♥')));
}

// --- Toggle Switch ---
function ToggleSwitch({
  checked,
  onChange,
  leftLabel,
  rightLabel
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: 8,
      fontSize: 13,
      cursor: 'pointer'
    },
    onClick: () => onChange(!checked)
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      color: !checked ? '#2a2a2a' : '#aaa',
      fontWeight: !checked ? 'bold' : 'normal',
      transition: 'all 0.15s',
      minWidth: 120,
      textAlign: 'left'
    }
  }, leftLabel), /*#__PURE__*/React.createElement("div", {
    style: {
      width: 36,
      height: 20,
      background: checked ? '#2a2a2a' : '#ccc',
      borderRadius: 10,
      position: 'relative',
      transition: 'background 0.2s',
      flexShrink: 0
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      width: 16,
      height: 16,
      background: '#fff',
      borderRadius: '50%',
      position: 'absolute',
      top: 2,
      left: checked ? 18 : 2,
      transition: 'left 0.2s',
      boxShadow: '0 1px 2px rgba(0,0,0,0.2)'
    }
  })), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      color: checked ? '#2a2a2a' : '#aaa',
      fontWeight: checked ? 'bold' : 'normal',
      transition: 'all 0.15s'
    }
  }, rightLabel));
}

// --- Player Scoresheet Component ---
function PlayerSheet({
  playerIdx,
  ps,
  bank,
  phase,
  round,
  roundHistory,
  classicMode,
  laxPlacement,
  cellHints,
  crossOut,
  verticalCategories,
  onUpdatePlayer,
  onToggleBankSelection,
  onBookDigit,
  onUndo,
  onEndRound,
  onUseBonusBook,
  onEndBonusBook,
  onEndgameBonusDone,
  twoPlayer,
  redInk
}) {
  const grids = ps.grids;
  const seqBonusI = hasSequenceBonusI(grids);
  const seqBonusIIA = hasSequenceBonusIIA(grids);
  const seqBonusIIB = classicMode ? false : hasSequenceBonusIIB(grids);
  const seqBonusIII = classicMode ? hasSequenceBonusIII(grids) : hasModernBonusIII(grids, laxPlacement);
  const rawScore = totalScore(grids, laxPlacement);
  const currentScore = rawScore + (seqBonusIII ? 5 : 0);
  const bonusBookCategories = (() => {
    if (!ps.bonusBookPhase) return ['sequence', 'matching', 'ladder'];
    if (ps.bonusBookSource === 'A') {
      if (ps.seqBonusIIBUsed && ps.seqBonusIIBCategory === '?') return ['sequence'];
      return ['sequence', 'matching', 'ladder'];
    }
    if (ps.bonusBookSource === 'B') {
      if (ps.seqBonusIIAUsed && ps.seqBonusIIACategory === '?') return ['sequence'];
      return ['sequence', 'matching', 'ladder'];
    }
    return ['sequence', 'matching', 'ladder'];
  })();
  const canSelectBank = phase === 'book' && !ps.roundDone && (ps.bonusBookPhase || ps.bookingsThisRound < ps.maxBooking) || phase === 'endgame-bonus' && ps.bonusBookPhase && !ps.roundDone;
  const playerLabel = twoPlayer ? `Player ${playerIdx + 1}` : null;
  const playerColor = playerIdx === 0 ? '#2a6fdb' : '#d4442a';
  return /*#__PURE__*/React.createElement("div", {
    style: {
      flex: 1,
      minWidth: 0,
      border: twoPlayer ? '2px solid #ddd' : 'none',
      borderRadius: twoPlayer ? 8 : 0,
      padding: twoPlayer ? '12px 10px' : 0,
      background: twoPlayer ? '#fefcf6' : 'transparent'
    }
  }, playerLabel && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 18,
      fontWeight: 'bold',
      textAlign: 'center',
      marginBottom: 8,
      color: playerColor
    }
  }, playerLabel, ps.roundDone && (phase === 'book' || phase === 'endgame-bonus') && /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      fontWeight: 'normal',
      opacity: 0.6,
      marginLeft: 8
    }
  }, "\u2713 Done")), /*#__PURE__*/React.createElement("div", {
    style: {
      textAlign: 'center',
      marginBottom: 12
    }
  }, /*#__PURE__*/React.createElement(ScoreTrack, {
    score: rawScore,
    bonusIII: seqBonusIII,
    crossOut: crossOut
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 16,
      fontWeight: 'bold'
    }
  }, "Score: ", currentScore, " / 100")), phase === 'choose' && /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      marginBottom: 6,
      textAlign: 'center'
    }
  }, "Choose your category:"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 8,
      justifyContent: 'center'
    }
  }, ['sequence', 'matching', 'ladder'].map(cat => /*#__PURE__*/React.createElement("button", {
    key: cat,
    onClick: () => onUpdatePlayer(playerIdx, {
      chosenCategory: ps.chosenCategory === cat ? null : cat
    }),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 16,
      padding: '6px 16px',
      background: ps.chosenCategory === cat ? '#2a2a2a' : '#fff',
      color: ps.chosenCategory === cat ? '#fff' : '#2a2a2a',
      border: '2px solid #2a2a2a',
      borderRadius: 4,
      cursor: 'pointer',
      transition: 'all 0.15s'
    }
  }, cat[0].toUpperCase()))), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      textAlign: 'center',
      marginTop: 4,
      opacity: 0.6
    }
  }, ps.chosenCategory ? `${ps.chosenCategory.charAt(0).toUpperCase() + ps.chosenCategory.slice(1)} selected` : 'S = Sequence · M = Matching · L = Ladder')), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 12,
      flexWrap: 'wrap'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      flex: '0 0 auto'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 13,
      fontWeight: 'bold',
      marginBottom: 4
    }
  }, "Bank"), Array.from({
    length: TOTAL_ROUNDS
  }, (_, r) => {
    const roundDigits = bank.filter(b => b.round === r);
    const startIdx = bank.indexOf(roundDigits[0]);
    const history = roundHistory[r];
    return /*#__PURE__*/React.createElement("div", {
      key: r,
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: 3,
        marginBottom: 1,
        opacity: r > round ? 0.3 : 1
      }
    }, /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        width: 18,
        textAlign: 'right'
      }
    }, r + 1, "."), /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 11,
        width: 12,
        textAlign: 'center',
        textDecoration: history ? 'underline' : 'none',
        fontWeight: history ? 'bold' : 'normal'
      }
    }, r < round && history ? ps.chosenCategory && r === round ? ps.chosenCategory[0].toUpperCase() : roundHistory[r] ? roundHistory[r].categories?.[playerIdx]?.[0]?.toUpperCase() || '·' : '·' : r === round && ps.chosenCategory ? ps.chosenCategory[0].toUpperCase() : '·'), /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        gap: 1
      }
    }, roundDigits.length > 0 ? roundDigits.map((b, i) => {
      const globalIdx = startIdx + i;
      return /*#__PURE__*/React.createElement(BankDigit, {
        key: i,
        digit: b.digit,
        used: ps.bankUsed[globalIdx],
        selected: ps.selectedBankIndices.includes(globalIdx),
        selectable: canSelectBank && !ps.bankUsed[globalIdx],
        onClick: () => onToggleBankSelection(playerIdx, globalIdx),
        crossOut: crossOut
      });
    }) : /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 11,
        opacity: 0.3,
        lineHeight: '32px'
      }
    }, "\xB7 \xB7 \xB7")));
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 12,
      flex: 1,
      minWidth: 0,
      flexDirection: verticalCategories ? 'column' : 'row'
    }
  }, ['sequence', 'matching', 'ladder'].map(cat => {
    const catLabel = cat.charAt(0).toUpperCase() + cat.slice(1);
    const scoreInfo = cat === 'sequence' ? 'XYZ=10 / WXYZ=15' : cat === 'matching' ? 'XXX=15 / XXXX=20' : 'XXYY=20 (Y=X±1)';
    const canBookHere = phase === 'book' && !ps.roundDone && ps.chosenCategory === cat || ps.bonusBookPhase && !ps.roundDone && bonusBookCategories.includes(cat) || phase === 'endgame-bonus' && ps.bonusBookPhase && !ps.roundDone && bonusBookCategories.includes(cat);
    return /*#__PURE__*/React.createElement("div", {
      key: cat,
      style: {
        flex: 1,
        minWidth: 0
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        marginBottom: 3
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 14,
        fontWeight: 'bold',
        fontStyle: 'italic'
      }
    }, catLabel), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 10,
        opacity: 0.5
      }
    }, scoreInfo)), grids[cat].map((row, rowIdx) => {
      const rowScore = scoreRow(cat, row, laxPlacement);
      const scoringCells = (() => {
        if (rowScore === 0) return new Set();
        if (cat === 'ladder') return new Set(row.map((c, i) => c !== null ? i : -1).filter(i => i !== -1));
        if (cat === 'matching') {
          const filled = row.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
          if (rowScore === 20) return new Set(filled);
          if (laxPlacement) return new Set(filled);
          for (let start = 0; start <= filled.length - 3; start++) {
            const group = filled.slice(start, start + 3);
            if (group[2] - group[0] === 2) return new Set(group);
          }
          return new Set();
        }
        if (cat === 'sequence') {
          const filled = row.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
          if (rowScore === 15 && filled.length === 4) return new Set(filled);
          for (let start = 0; start <= filled.length - 3; start++) {
            const group = filled.slice(start, start + 3);
            if (group[2] - group[0] === 2) {
              const digits = group.map(i => row[i]);
              if (isValidSequence(digits)) return new Set(group);
            }
          }
          return new Set();
        }
        return new Set();
      })();
      const selectedDigit = ps.selectedBankIndices.length === 1 ? bank[ps.selectedBankIndices[0]].digit : null;
      const canPlaceInCell = colIdx => {
        if (!canBookHere || row[colIdx] !== null || selectedDigit === null) return false;
        if (cat === 'sequence') {
          const existing = row.map((d, i) => d !== null ? {
            digit: d,
            pos: i
          } : null).filter(Boolean);
          return canExtendSequence(existing, selectedDigit, colIdx);
        } else if (cat === 'matching') {
          const existing = row.filter(c => c !== null);
          return existing.length === 0 || existing[0] === selectedDigit;
        } else if (cat === 'ladder') {
          const newRow = [...row];
          newRow[colIdx] = selectedDigit;
          return laxPlacement ? isValidLaxLadderPlacement(newRow) : isValidLadderPlacement(newRow);
        }
        return true;
      };
      const rowHints = cellHints ? getCellHints(cat, row, laxPlacement) : null;
      return /*#__PURE__*/React.createElement("div", {
        key: rowIdx,
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: 2,
          marginBottom: 2
        }
      }, row.map((cell, colIdx) => /*#__PURE__*/React.createElement(GridCell, {
        key: colIdx,
        value: cell,
        clickable: canPlaceInCell(colIdx),
        highlight: scoringCells.has(colIdx),
        onClick: () => onBookDigit(playerIdx, cat, rowIdx, colIdx),
        hints: rowHints ? rowHints[colIdx] : null
      })), rowScore > 0 && /*#__PURE__*/React.createElement("span", {
        style: {
          fontSize: 12,
          fontWeight: 'bold',
          color: redInk,
          marginLeft: 3
        }
      }, "+", rowScore));
    }));
  }))), (phase === 'book' || phase === 'endgame-bonus') && !ps.roundDone && /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      paddingTop: 8,
      marginTop: 6
    }
  }, !ps.bonusBookPhase && phase === 'book' && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      marginBottom: 6
    }
  }, /*#__PURE__*/React.createElement("strong", null, "Booking into ", ps.chosenCategory?.charAt(0).toUpperCase() + ps.chosenCategory?.slice(1)), ' · ', ps.bookingsThisRound, " / ", ps.maxBooking, " booked"), ps.bonusBookPhase && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      marginBottom: 6,
      color: redInk
    }
  }, /*#__PURE__*/React.createElement("strong", null, "\uD83C\uDF81 Bonus Book!"), " Place 1 digit into ", bonusBookCategories.length === 3 ? 'any category' : 'Sequence', ".", /*#__PURE__*/React.createElement("button", {
    onClick: () => onEndBonusBook(playerIdx),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 11,
      marginLeft: 6,
      padding: '2px 6px',
      background: '#eee',
      border: '1px solid #ccc',
      borderRadius: 3,
      cursor: 'pointer'
    }
  }, "Cancel")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 6,
      flexWrap: 'wrap',
      alignItems: 'center'
    }
  }, !ps.bonusBookPhase && phase === 'book' && /*#__PURE__*/React.createElement(React.Fragment, null, ps.seqBonusIIAUnlocked && !ps.seqBonusIIAUsed && /*#__PURE__*/React.createElement("button", {
    onClick: () => onUseBonusBook(playerIdx, 'A'),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 12,
      padding: '4px 10px',
      background: '#fffde6',
      border: '1.5px solid #b8860b',
      borderRadius: 4,
      cursor: 'pointer',
      color: '#8b6914'
    }
  }, classicMode ? 'Use Seq Bonus II' : 'Use Seq Bonus II-A'), !classicMode && ps.seqBonusIIBUnlocked && !ps.seqBonusIIBUsed && /*#__PURE__*/React.createElement("button", {
    onClick: () => onUseBonusBook(playerIdx, 'B'),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 12,
      padding: '4px 10px',
      background: '#fffde6',
      border: '1.5px solid #b8860b',
      borderRadius: 4,
      cursor: 'pointer',
      color: '#8b6914'
    }
  }, "Use Seq Bonus II-B")), !ps.bonusBookPhase && /*#__PURE__*/React.createElement(React.Fragment, null, ps.undoStack.length > 0 && /*#__PURE__*/React.createElement("button", {
    onClick: () => onUndo(playerIdx),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 12,
      padding: '4px 10px',
      background: '#fff',
      color: '#888',
      border: '1.5px solid #ccc',
      borderRadius: 4,
      cursor: 'pointer'
    },
    onMouseEnter: e => {
      e.target.style.color = '#c0392b';
      e.target.style.borderColor = '#c0392b';
    },
    onMouseLeave: e => {
      e.target.style.color = '#888';
      e.target.style.borderColor = '#ccc';
    }
  }, "\u21A9 Undo"), /*#__PURE__*/React.createElement("button", {
    onClick: () => onEndRound(playerIdx),
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 13,
      padding: '4px 14px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 4,
      cursor: 'pointer',
      marginLeft: 'auto'
    }
  }, phase === 'endgame-bonus' ? 'Finish' : round >= TOTAL_ROUNDS - 1 ? 'End Game' : 'End Round')))), phase === 'endgame-bonus' && !ps.bonusBookPhase && !ps.roundDone && (() => {
    const anyUnused = ps.seqBonusIIAUnlocked && !ps.seqBonusIIAUsed || ps.seqBonusIIBUnlocked && !ps.seqBonusIIBUsed;
    return /*#__PURE__*/React.createElement("div", {
      style: {
        padding: 10,
        marginTop: 6,
        background: '#fffde6',
        border: '1.5px solid #b8860b',
        borderRadius: 6
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 13,
        fontWeight: 'bold',
        color: '#8b6914',
        marginBottom: 4
      }
    }, anyUnused ? 'Use remaining Sequence Bonuses!' : 'All bonuses used!'), /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        gap: 6,
        alignItems: 'center',
        flexWrap: 'wrap'
      }
    }, ps.seqBonusIIAUnlocked && !ps.seqBonusIIAUsed && /*#__PURE__*/React.createElement("button", {
      onClick: () => onUseBonusBook(playerIdx, 'A'),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 12,
        padding: '4px 10px',
        background: '#fff',
        border: '1.5px solid #b8860b',
        borderRadius: 4,
        cursor: 'pointer'
      }
    }, classicMode ? 'Use Seq Bonus II' : 'Use Seq Bonus II-A'), !classicMode && ps.seqBonusIIBUnlocked && !ps.seqBonusIIBUsed && /*#__PURE__*/React.createElement("button", {
      onClick: () => onUseBonusBook(playerIdx, 'B'),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 12,
        padding: '4px 10px',
        background: '#fff',
        border: '1.5px solid #b8860b',
        borderRadius: 4,
        cursor: 'pointer'
      }
    }, "Use Seq Bonus II-B"), ps.undoStack.length > 0 && /*#__PURE__*/React.createElement("button", {
      onClick: () => onUndo(playerIdx),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 12,
        padding: '4px 10px',
        background: '#fff',
        color: '#888',
        border: '1.5px solid #ccc',
        borderRadius: 4,
        cursor: 'pointer'
      }
    }, "\u21A9 Undo"), /*#__PURE__*/React.createElement("button", {
      onClick: () => onEndgameBonusDone(playerIdx),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 12,
        padding: '4px 12px',
        background: '#2a2a2a',
        color: '#fff',
        border: 'none',
        borderRadius: 4,
        cursor: 'pointer',
        marginLeft: 'auto'
      }
    }, anyUnused ? 'Skip & Finish' : 'Finish')));
  })(), /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      paddingTop: 6,
      marginTop: 8,
      fontSize: 11,
      opacity: 0.7
    }
  }, /*#__PURE__*/React.createElement("strong", null, "Sequence Bonus:"), ' ', /*#__PURE__*/React.createElement("span", {
    style: {
      color: seqBonusI ? '#27ae60' : '#999'
    }
  }, "I ", seqBonusI ? '✓' : '○'), ' · ', classicMode ? /*#__PURE__*/React.createElement("span", {
    style: {
      color: ps.seqBonusIIAUnlocked ? '#27ae60' : '#999'
    }
  }, "II ", ps.seqBonusIIAUnlocked ? ps.seqBonusIIAUsed ? `✓(${ps.seqBonusIIACategory})` : '★' : '○') : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
    style: {
      color: ps.seqBonusIIAUnlocked ? '#27ae60' : '#999'
    }
  }, "II-A ", ps.seqBonusIIAUnlocked ? ps.seqBonusIIAUsed ? `✓(${ps.seqBonusIIACategory})` : '★' : '○'), ' · ', /*#__PURE__*/React.createElement("span", {
    style: {
      color: ps.seqBonusIIBUnlocked ? '#27ae60' : '#999'
    }
  }, "II-B ", ps.seqBonusIIBUnlocked ? ps.seqBonusIIBUsed ? `✓(${ps.seqBonusIIBCategory})` : '★' : '○')), ' · ', /*#__PURE__*/React.createElement("span", {
    style: {
      color: seqBonusIII ? '#27ae60' : '#999'
    }
  }, "III ", seqBonusIII ? '✓ (+5)' : '○')));
}

// --- Main Game Component ---
window.Simili = function Simili() {
  const [showSettings, setShowSettings] = useState(false);
  const [wideLayout, setWideLayout] = useState(false);
  const [verticalCategories, setVerticalCategories] = useState(false);
  const [cellHints, setCellHints] = useState(false);
  const [crossOut, setCrossOut] = useState(false);
  const [twoPlayer, setTwoPlayer] = useState(false);
  const [matchPlay, setMatchPlay] = useState(false);
  const [classicMode, setClassicMode] = useState(false);
  const [laxPlacement, setLaxPlacement] = useState(false);
  const [seedRolls, setSeedRolls] = useState(() => {
    try {
      const params = new URLSearchParams(window.location.search);
      const seed = params.get('seed');
      if (seed && /^\d{30}$/.test(seed)) {
        const rolls = [];
        for (let i = 0; i < 30; i += 3) rolls.push([parseInt(seed[i]), parseInt(seed[i + 1]), parseInt(seed[i + 2])]);
        return rolls;
      }
    } catch (e) {}
    return null;
  });

  // Match Play state
  const [matchGameNum, setMatchGameNum] = useState(0);
  const [matchScores, setMatchScores] = useState([]); // [{p1, p2?}, ...]
  const [matchPhase, setMatchPhase] = useState('playing'); // 'playing'|'between'|'done'|'sudden-death'

  // Game state (shared)
  const [round, setRound] = useState(0);
  const [phase, setPhase] = useState('pregame');
  const [abandoned, setAbandoned] = useState(false);
  const [currentRoll, setCurrentRoll] = useState([null, null, null]);
  const [spinning, setSpinning] = useState(false);
  const [bank, setBank] = useState([]);
  const [roundHistory, setRoundHistory] = useState([]);

  // Player states
  const [players, setPlayers] = useState([createPlayerState()]);
  useEffect(() => {
    if (phase === 'pregame') {
      setPlayers(twoPlayer ? [createPlayerState(), createPlayerState()] : [createPlayerState()]);
    }
  }, [twoPlayer]);
  const abandonedRef = useRef(false);
  useEffect(() => {
    abandonedRef.current = abandoned;
  }, [abandoned]);
  const numPlayers = twoPlayer ? 2 : 1;
  const updatePlayer = (idx, updates) => {
    setPlayers(prev => prev.map((p, i) => i === idx ? {
      ...p,
      ...updates
    } : p));
  };
  const updatePlayerFn = (idx, fn) => {
    setPlayers(prev => prev.map((p, i) => i === idx ? fn(p) : p));
  };
  const allCategoriesChosen = () => {
    for (let i = 0; i < numPlayers; i++) {
      if (!players[i]?.chosenCategory) return false;
    }
    return true;
  };

  // In 1-player mode, auto-lock category when chosen (no separate lock step needed)
  // Actually keep the lock button for consistency, but in 1P mode we can skip it
  // Let's keep the explicit lock for both modes for clarity

  const handleRoll = () => {
    setPlayers(prev => prev.map(p => ({
      ...p,
      maxBooking: p.chosenCategory === 'sequence' && hasSequenceBonusI(p.grids) ? MAX_BOOK_SEQ_BONUS : MAX_BOOK_DEFAULT
    })));
    const roll = seedRolls && seedRolls[round] ? seedRolls[round] : [Math.floor(Math.random() * 10), Math.floor(Math.random() * 10), Math.floor(Math.random() * 10)];
    setCurrentRoll(roll);
    setSpinning(true);
    setPhase('rolling');
    setTimeout(() => {
      if (abandonedRef.current) return;
      setSpinning(false);
      setPhase('book');
      setBank(prev => {
        const newBank = [...prev, ...roll.map(d => ({
          digit: d,
          round
        }))];
        setPlayers(prevP => prevP.map(p => ({
          ...p,
          bankUsed: [...p.bankUsed, false, false, false],
          bookingsThisRound: 0,
          undoStack: [],
          roundDone: false
        })));
        return newBank;
      });
      setRoundHistory(prev => [...prev, {
        roll,
        round,
        categories: players.map(p => p.chosenCategory)
      }]);
    }, 2200);
  };
  const toggleBankSelection = (playerIdx, bankIdx) => {
    updatePlayerFn(playerIdx, p => ({
      ...p,
      selectedBankIndices: p.selectedBankIndices.includes(bankIdx) ? p.selectedBankIndices.filter(i => i !== bankIdx) : [bankIdx]
    }));
  };
  const handleBookDigit = (playerIdx, category, rowIdx, colIdx) => {
    const p = players[playerIdx];
    if (p.selectedBankIndices.length !== 1) return;
    const bankIdx = p.selectedBankIndices[0];
    const digit = bank[bankIdx].digit;
    const row = p.grids[category][rowIdx];
    if (row[colIdx] !== null) return;
    const isBonusBook = p.bonusBookPhase;
    if (!isBonusBook && p.bookingsThisRound >= p.maxBooking) return;
    if (category === 'sequence') {
      const existing = row.map((d, i) => d !== null ? {
        digit: d,
        pos: i
      } : null).filter(Boolean);
      if (!canExtendSequence(existing, digit, colIdx)) return;
    } else if (category === 'matching') {
      const existing = row.filter(c => c !== null);
      if (existing.length > 0 && existing[0] !== digit) return;
    } else if (category === 'ladder') {
      const newRow = [...row];
      newRow[colIdx] = digit;
      if (laxPlacement ? !isValidLaxLadderPlacement(newRow) : !isValidLadderPlacement(newRow)) return;
    }
    updatePlayerFn(playerIdx, p => {
      const snapshot = {
        grids: {
          sequence: p.grids.sequence.map(r => [...r]),
          matching: p.grids.matching.map(r => [...r]),
          ladder: p.grids.ladder.map(r => [...r])
        },
        bankUsed: [...p.bankUsed],
        bookingsThisRound: p.bookingsThisRound,
        maxBooking: p.maxBooking,
        bonusBookPhase: p.bonusBookPhase,
        bonusBookSource: p.bonusBookSource,
        seqBonusIIAUsed: p.seqBonusIIAUsed,
        seqBonusIIBUsed: p.seqBonusIIBUsed,
        seqBonusIIAUnlocked: p.seqBonusIIAUnlocked,
        seqBonusIIBUnlocked: p.seqBonusIIBUnlocked,
        seqBonusIIACategory: p.seqBonusIIACategory,
        seqBonusIIBCategory: p.seqBonusIIBCategory
      };
      const newGrids = {
        ...p.grids
      };
      newGrids[category] = p.grids[category].map((r, ri) => ri === rowIdx ? r.map((c, ci) => ci === colIdx ? digit : c) : [...r]);
      const newBankUsed = [...p.bankUsed];
      newBankUsed[bankIdx] = true;
      let ns = {
        ...p,
        grids: newGrids,
        bankUsed: newBankUsed,
        selectedBankIndices: [],
        undoStack: [...p.undoStack, snapshot]
      };
      if (hasSequenceBonusIIA(newGrids) && !p.seqBonusIIAUnlocked) ns.seqBonusIIAUnlocked = true;
      if (!classicMode && hasSequenceBonusIIB(newGrids) && !p.seqBonusIIBUnlocked) ns.seqBonusIIBUnlocked = true;
      if (isBonusBook) {
        if (p.bonusBookSource === 'A') {
          ns.seqBonusIIAUsed = true;
          ns.seqBonusIIACategory = category === 'sequence' ? 'S' : '?';
        } else {
          ns.seqBonusIIBUsed = true;
          ns.seqBonusIIBCategory = category === 'sequence' ? 'S' : '?';
        }
        ns.bonusBookPhase = false;
        ns.bonusBookSource = null;
      } else {
        ns.bookingsThisRound = p.bookingsThisRound + 1;
      }
      return ns;
    });
  };
  const handleUndo = playerIdx => {
    updatePlayerFn(playerIdx, p => {
      if (p.undoStack.length === 0) return p;
      const s = p.undoStack[p.undoStack.length - 1];
      return {
        ...p,
        grids: s.grids,
        bankUsed: s.bankUsed,
        bookingsThisRound: s.bookingsThisRound,
        maxBooking: s.maxBooking,
        seqBonusIIAUsed: s.seqBonusIIAUsed,
        seqBonusIIBUsed: s.seqBonusIIBUsed,
        seqBonusIIAUnlocked: s.seqBonusIIAUnlocked,
        seqBonusIIBUnlocked: s.seqBonusIIBUnlocked,
        seqBonusIIACategory: s.seqBonusIIACategory,
        seqBonusIIBCategory: s.seqBonusIIBCategory,
        selectedBankIndices: [],
        bonusBookPhase: phase === 'endgame-bonus' ? false : s.bonusBookPhase,
        bonusBookSource: phase === 'endgame-bonus' ? null : s.bonusBookSource,
        undoStack: p.undoStack.slice(0, -1)
      };
    });
  };
  const handleEndRound = playerIdx => {
    updatePlayer(playerIdx, {
      selectedBankIndices: [],
      roundDone: true
    });
  };

  // Advance when all players done booking
  const prevPhaseRef = useRef(phase);
  const prevPlayersDoneRef = useRef(false);
  useEffect(() => {
    if (phase !== 'book') {
      prevPhaseRef.current = phase;
      return;
    }
    const allDone = players.every(p => p.roundDone);
    if (!allDone) {
      prevPlayersDoneRef.current = false;
      return;
    }
    if (prevPlayersDoneRef.current) return; // already processed
    prevPlayersDoneRef.current = true;
    if (round >= TOTAL_ROUNDS - 1) {
      const anyHasBonus = players.some(p => {
        return p.seqBonusIIAUnlocked && !p.seqBonusIIAUsed || p.seqBonusIIBUnlocked && !p.seqBonusIIBUsed;
      });
      if (anyHasBonus) {
        setPhase('endgame-bonus');
        setPlayers(prev => prev.map(p => {
          const hasUnused = p.seqBonusIIAUnlocked && !p.seqBonusIIAUsed || p.seqBonusIIBUnlocked && !p.seqBonusIIBUsed;
          return {
            ...p,
            roundDone: !hasUnused,
            undoStack: []
          };
        }));
      } else {
        setPhase('gameover');
      }
    } else {
      setRound(prev => prev + 1);
      setPhase('choose');
      setPlayers(prev => prev.map(p => ({
        ...p,
        chosenCategory: null,
        roundDone: false
      })));
    }
    prevPhaseRef.current = phase;
  }, [players, phase, round]);

  // Advance endgame-bonus
  useEffect(() => {
    if (phase !== 'endgame-bonus') return;
    if (players.every(p => p.roundDone)) setPhase('gameover');
  }, [players, phase]);
  const handleUseBonusBook = (playerIdx, source) => {
    updatePlayer(playerIdx, {
      bonusBookPhase: true,
      bonusBookSource: source
    });
  };
  const handleEndBonusBook = playerIdx => {
    updatePlayer(playerIdx, {
      bonusBookPhase: false,
      bonusBookSource: null
    });
  };
  const handleEndgameBonusDone = playerIdx => {
    updatePlayer(playerIdx, {
      roundDone: true,
      selectedBankIndices: []
    });
  };

  // --- Match Play Logic ---
  const handleMatchNextGame = () => {
    const scores = players.map(p => {
      const s = getPlayerFinalScore(p, classicMode, laxPlacement);
      return s >= 100 ? s : 0;
    });
    const newScores = [...matchScores, twoPlayer ? {
      p1: scores[0],
      p2: scores[1]
    } : {
      p1: scores[0]
    }];
    setMatchScores(newScores);
    if (matchPhase === 'sudden-death') {
      // Check if sudden death resolved the tie
      if (twoPlayer && scores[0] !== scores[1]) {
        setMatchPhase('done');
      } else if (!twoPlayer) {
        setMatchPhase('done');
      }
      // else still tied, stay in sudden-death
      return;
    }
    if (matchGameNum + 1 >= MATCH_GAMES) {
      setMatchPhase('done');
    } else {
      setMatchPhase('between');
    }
  };
  const resetGameState = () => {
    setRound(0);
    setPhase('choose');
    setAbandoned(false);
    setCurrentRoll([null, null, null]);
    setSpinning(false);
    setBank([]);
    setRoundHistory([]);
    setPlayers(twoPlayer ? [createPlayerState(), createPlayerState()] : [createPlayerState()]);
    setSeedRolls(null);
  };
  const handleMatchContinue = () => {
    setMatchGameNum(prev => prev + 1);
    setMatchPhase('playing');
    resetGameState();
  };
  const handleSuddenDeath = () => {
    setMatchPhase('sudden-death');
    resetGameState();
  };
  const handleReset = () => {
    setRound(0);
    setPhase('pregame');
    setAbandoned(false);
    setCurrentRoll([null, null, null]);
    setSpinning(false);
    setBank([]);
    setRoundHistory([]);
    setPlayers(twoPlayer ? [createPlayerState(), createPlayerState()] : [createPlayerState()]);
    setSeedRolls(null);
    setMatchGameNum(0);
    setMatchScores([]);
    setMatchPhase('playing');
  };
  const computeMatchResult = scores => {
    const p1Total = scores.reduce((s, g) => s + g.p1, 0);
    const p2Total = scores.reduce((s, g) => s + (g.p2 || 0), 0);
    if (!twoPlayer) return {
      winner: p1Total > 0 ? 1 : 0,
      p1Total,
      p2Total: 0
    };
    if (p1Total !== p2Total) return {
      winner: p1Total > p2Total ? 1 : 2,
      p1Total,
      p2Total
    };
    for (let i = scores.length - 1; i >= 0; i--) {
      if (scores[i].p1 !== scores[i].p2) return {
        winner: scores[i].p1 > scores[i].p2 ? 1 : 2,
        p1Total,
        p2Total,
        tiebreak: true
      };
    }
    return {
      winner: 0,
      p1Total,
      p2Total,
      tied: true
    };
  };
  const paperBg = '#faf6ed';
  const inkColor = '#2a2a2a';
  const redInk = '#c0392b';
  const gameOverInfo = phase === 'gameover' ? players.map(p => {
    const score = getPlayerFinalScore(p, classicMode, laxPlacement);
    const won = !abandoned && score >= 100;
    const unwinnable = !abandoned && !won && bank.length === 30 && isUnwinnableSequence(bank);
    return {
      score,
      won,
      unwinnable
    };
  }) : [];
  return /*#__PURE__*/React.createElement("div", {
    style: {
      minHeight: '100vh',
      background: 'linear-gradient(to bottom, #f0ebe0, #faf6ed 5%, #faf6ed 95%, #f0ebe0)',
      fontFamily: "'Special Elite', 'Courier New', monospace",
      color: inkColor,
      padding: '20px 8px'
    }
  }, /*#__PURE__*/React.createElement("style", null, `
        @import url('https://fonts.googleapis.com/css2?family=Special+Elite&display=swap');
        * { box-sizing: border-box; }
        @keyframes reelSpin { 0% { transform: translateY(0); } 25% { transform: translateY(-8px); } 50% { transform: translateY(0); } 75% { transform: translateY(8px); } 100% { transform: translateY(0); } }
      `), /*#__PURE__*/React.createElement("div", {
    style: {
      maxWidth: wideLayout ? twoPlayer ? 1600 : 1200 : twoPlayer ? 1000 : 800,
      margin: '0 auto',
      background: '#fff',
      border: '2px solid #ccc',
      borderRadius: 4,
      padding: '24px 20px',
      boxShadow: '4px 4px 0 #ddd, 2px 2px 0 #e8e4d8',
      position: 'relative'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      position: 'absolute',
      top: 12,
      left: -8,
      width: 16,
      height: 16,
      borderRadius: '50%',
      background: paperBg,
      border: '1px solid #ccc'
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      position: 'absolute',
      top: 12,
      right: -8,
      width: 16,
      height: 16,
      borderRadius: '50%',
      background: paperBg,
      border: '1px solid #ccc'
    }
  }), /*#__PURE__*/React.createElement("h1", {
    style: {
      textAlign: 'center',
      fontSize: 42,
      margin: '0 0 8px',
      letterSpacing: 8,
      fontWeight: 'bold'
    }
  }, /*#__PURE__*/React.createElement("span", null, "S"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: '0.75em'
    }
  }, "I"), /*#__PURE__*/React.createElement("span", null, "M"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: '0.75em'
    }
  }, "I"), /*#__PURE__*/React.createElement("span", null, "L"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: '0.75em'
    }
  }, "I")), matchPlay && phase !== 'pregame' && /*#__PURE__*/React.createElement("div", {
    style: {
      textAlign: 'center',
      marginBottom: 12,
      padding: '8px 16px',
      background: '#f5f0e6',
      border: '1px solid #ddd',
      borderRadius: 6
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      fontWeight: 'bold',
      marginBottom: 4
    }
  }, matchPhase === 'sudden-death' ? '⚡ Sudden Death' : `Match: Game ${matchGameNum + 1} of ${MATCH_GAMES}`), matchScores.length > 0 && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      opacity: 0.7
    }
  }, twoPlayer ? /*#__PURE__*/React.createElement(React.Fragment, null, "P1: ", matchScores.reduce((s, g) => s + g.p1, 0), " \xB7 P2: ", matchScores.reduce((s, g) => s + (g.p2 || 0), 0), /*#__PURE__*/React.createElement("br", null), matchScores.map((g, i) => /*#__PURE__*/React.createElement("span", {
    key: i,
    style: {
      marginRight: 8
    }
  }, "G", i + 1, ": ", g.p1, "\u2013", g.p2))) : /*#__PURE__*/React.createElement(React.Fragment, null, "Total: ", matchScores.reduce((s, g) => s + g.p1, 0), /*#__PURE__*/React.createElement("br", null), matchScores.map((g, i) => /*#__PURE__*/React.createElement("span", {
    key: i,
    style: {
      marginRight: 8
    }
  }, "G", i + 1, ": ", g.p1))))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      marginBottom: 16,
      padding: '12px 0',
      borderTop: '1px dashed #ccc',
      borderBottom: '1px dashed #ccc'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      marginBottom: 8,
      opacity: 0.7
    }
  }, phase === 'pregame' ? matchPlay ? 'Configure settings below, then click Start Match.' : 'Configure settings below, then click Start Game.' : `Round ${round + 1} of ${TOTAL_ROUNDS}`), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 12,
      marginBottom: 12
    }
  }, [0, 1, 2].map(i => /*#__PURE__*/React.createElement(SlotReel, {
    key: i,
    targetDigit: currentRoll[i],
    spinning: spinning,
    delay: i * 300
  }))), phase === 'choose' && allCategoriesChosen() && /*#__PURE__*/React.createElement("button", {
    onClick: handleRoll,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 20,
      padding: '10px 40px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 6,
      cursor: 'pointer',
      letterSpacing: 2,
      transition: 'transform 0.1s'
    },
    onMouseDown: e => e.target.style.transform = 'scale(0.97)',
    onMouseUp: e => e.target.style.transform = 'scale(1)'
  }, "ROLL"), phase === 'choose' && !allCategoriesChosen() && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 13,
      opacity: 0.5
    }
  }, twoPlayer ? (() => {
    const waiting = players.map((p, i) => !p.chosenCategory ? `Player ${i + 1}` : null).filter(Boolean);
    return `Waiting for ${waiting.join(' & ')} to choose a category...`;
  })() : 'Choose a category to roll.'), phase === 'rolling' && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 16,
      opacity: 0.6
    }
  }, "Rolling...")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: twoPlayer ? 16 : 0,
      flexDirection: twoPlayer && !wideLayout ? 'column' : 'row'
    }
  }, players.map((ps, idx) => /*#__PURE__*/React.createElement(PlayerSheet, {
    key: idx,
    playerIdx: idx,
    ps: ps,
    bank: bank,
    phase: phase,
    round: round,
    roundHistory: roundHistory,
    classicMode: classicMode,
    laxPlacement: laxPlacement,
    cellHints: cellHints,
    crossOut: crossOut,
    verticalCategories: verticalCategories,
    onUpdatePlayer: updatePlayer,
    onToggleBankSelection: toggleBankSelection,
    onBookDigit: handleBookDigit,
    onUndo: handleUndo,
    onEndRound: handleEndRound,
    onUseBonusBook: handleUseBonusBook,
    onEndBonusBook: handleEndBonusBook,
    onEndgameBonusDone: handleEndgameBonusDone,
    twoPlayer: twoPlayer,
    redInk: redInk
  }))), phase === 'pregame' && /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      paddingTop: 12,
      marginTop: 8,
      display: 'flex',
      justifyContent: 'center'
    }
  }, /*#__PURE__*/React.createElement("button", {
    onClick: () => {
      setPhase('choose');
      setShowSettings(false);
    },
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 14,
      padding: '6px 20px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 4,
      cursor: 'pointer'
    }
  }, matchPlay ? 'Start Match' : 'Start Game')), phase === 'gameover' && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 20,
      padding: 24,
      textAlign: 'center',
      background: gameOverInfo.some(g => g.won) ? '#e8f5e9' : '#ffeaa7',
      border: `2px solid ${gameOverInfo.some(g => g.won) ? '#27ae60' : '#f39c12'}`,
      borderRadius: 8
    }
  }, twoPlayer ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontWeight: 'bold',
      marginBottom: 12
    }
  }, abandoned ? 'Game Abandoned' : (() => {
    const p1W = gameOverInfo[0]?.won,
      p2W = gameOverInfo[1]?.won;
    const p1S = gameOverInfo[0]?.score || 0,
      p2S = gameOverInfo[1]?.score || 0;
    if (p1W && p2W) return p1S > p2S ? 'Player 1 Leads!' : p2S > p1S ? 'Player 2 Leads!' : 'Both Win — Tied!';
    if (p1W) return 'Player 1 Wins!';
    if (p2W) return 'Player 2 Wins!';
    if (gameOverInfo[0]?.unwinnable && gameOverInfo[1]?.unwinnable) return 'This game was impossible to win!';
    return 'Game Over — Neither Player Won';
  })()), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      justifyContent: 'center',
      gap: 32,
      marginBottom: 12
    }
  }, gameOverInfo.map((g, i) => /*#__PURE__*/React.createElement("div", {
    key: i
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      fontWeight: 'bold',
      color: i === 0 ? '#2a6fdb' : '#d4442a'
    }
  }, "Player ", i + 1), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 20
    }
  }, abandoned ? 'Abandoned' : /*#__PURE__*/React.createElement(React.Fragment, null, g.score, " pts ", g.won ? '✓' : '✗', g.score > 100 && /*#__PURE__*/React.createElement("span", {
    style: {
      color: redInk,
      fontSize: 14
    }
  }, " (\u2665", g.score - 100, ")"))), matchPlay && !abandoned && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      opacity: 0.6
    }
  }, "Match pts: ", g.won ? g.score : 0))))) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 28,
      fontWeight: 'bold',
      marginBottom: 8
    }
  }, abandoned ? 'Game Abandoned' : gameOverInfo[0]?.won ? '🎉 YOU WIN!' : gameOverInfo[0]?.unwinnable ? 'This game was impossible to win!' : 'Game Over'), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 20,
      marginBottom: 4
    }
  }, abandoned ? 'Game was Abandoned' : /*#__PURE__*/React.createElement(React.Fragment, null, "Final Score: ", gameOverInfo[0]?.score, gameOverInfo[0]?.score > 100 && /*#__PURE__*/React.createElement("span", {
    style: {
      color: redInk
    }
  }, " (\u2665", gameOverInfo[0].score - 100, ")")))), matchPlay && !abandoned && (matchPhase === 'playing' || matchPhase === 'sudden-death') && /*#__PURE__*/React.createElement("button", {
    onClick: handleMatchNextGame,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 18,
      padding: '10px 32px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 6,
      cursor: 'pointer',
      marginTop: 16,
      letterSpacing: 2
    }
  }, matchPhase === 'sudden-death' ? 'SEE RESULT' : matchGameNum + 1 >= MATCH_GAMES ? 'SEE MATCH RESULTS' : 'NEXT GAME'), (!matchPlay || abandoned) && /*#__PURE__*/React.createElement("button", {
    onClick: handleReset,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 18,
      padding: '10px 32px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 6,
      cursor: 'pointer',
      marginTop: 16,
      letterSpacing: 2
    }
  }, "PLAY AGAIN")), matchPlay && matchPhase === 'between' && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 20,
      padding: 24,
      textAlign: 'center',
      background: '#e3f2fd',
      border: '2px solid #1976d2',
      borderRadius: 8
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 22,
      fontWeight: 'bold',
      marginBottom: 12
    }
  }, "Game ", matchGameNum + 1, " Complete!"), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      marginBottom: 16
    }
  }, twoPlayer ? /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      justifyContent: 'center',
      gap: 32
    }
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    style: {
      fontWeight: 'bold',
      color: '#2a6fdb'
    }
  }, "Player 1"), /*#__PURE__*/React.createElement("div", null, "Total: ", matchScores.reduce((s, g) => s + g.p1, 0))), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    style: {
      fontWeight: 'bold',
      color: '#d4442a'
    }
  }, "Player 2"), /*#__PURE__*/React.createElement("div", null, "Total: ", matchScores.reduce((s, g) => s + (g.p2 || 0), 0)))) : /*#__PURE__*/React.createElement("div", null, "Running Total: ", matchScores.reduce((s, g) => s + g.p1, 0))), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      marginBottom: 12,
      opacity: 0.7
    }
  }, matchScores.map((g, i) => /*#__PURE__*/React.createElement("span", {
    key: i,
    style: {
      marginRight: 12
    }
  }, "Game ", i + 1, ": ", twoPlayer ? `${g.p1}–${g.p2}` : g.p1))), /*#__PURE__*/React.createElement("button", {
    onClick: handleMatchContinue,
    style: {
      fontFamily: "'Special Elite', 'Courier New', monospace",
      fontSize: 18,
      padding: '10px 32px',
      background: '#2a2a2a',
      color: '#fff',
      border: 'none',
      borderRadius: 6,
      cursor: 'pointer',
      letterSpacing: 2
    }
  }, "START GAME ", matchGameNum + 2)), matchPlay && matchPhase === 'done' && (() => {
    const result = twoPlayer ? computeMatchResult(matchScores) : null;
    const p1T = matchScores.reduce((s, g) => s + g.p1, 0);
    const p2T = twoPlayer ? matchScores.reduce((s, g) => s + (g.p2 || 0), 0) : 0;
    return /*#__PURE__*/React.createElement("div", {
      style: {
        marginTop: 20,
        padding: 24,
        textAlign: 'center',
        background: '#fff9c4',
        border: '2px solid #f9a825',
        borderRadius: 8
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 28,
        fontWeight: 'bold',
        marginBottom: 12
      }
    }, "\uD83C\uDFC6 Match Complete!"), twoPlayer ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'center',
        gap: 40,
        marginBottom: 16
      }
    }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      style: {
        fontWeight: 'bold',
        fontSize: 18,
        color: '#2a6fdb'
      }
    }, "Player 1"), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 28
      }
    }, p1T)), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 24,
        alignSelf: 'center'
      }
    }, "vs"), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      style: {
        fontWeight: 'bold',
        fontSize: 18,
        color: '#d4442a'
      }
    }, "Player 2"), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 28
      }
    }, p2T))), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 12,
        marginBottom: 12
      }
    }, matchScores.map((g, i) => /*#__PURE__*/React.createElement("span", {
      key: i,
      style: {
        marginRight: 12
      }
    }, "Game ", i + 1, ": ", g.p1, "\u2013", g.p2))), result.tied ? /*#__PURE__*/React.createElement("div", {
      style: {
        marginBottom: 12
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 20,
        fontWeight: 'bold'
      }
    }, "Perfect Tie!"), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 13,
        marginTop: 4
      }
    }, "All games were tied. Play Sudden Death or call it a draw."), /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        gap: 12,
        justifyContent: 'center',
        marginTop: 12
      }
    }, /*#__PURE__*/React.createElement("button", {
      onClick: handleSuddenDeath,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 16,
        padding: '8px 24px',
        background: '#c0392b',
        color: '#fff',
        border: 'none',
        borderRadius: 6,
        cursor: 'pointer'
      }
    }, "\u26A1 SUDDEN DEATH"), /*#__PURE__*/React.createElement("button", {
      onClick: handleReset,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 16,
        padding: '8px 24px',
        background: '#888',
        color: '#fff',
        border: 'none',
        borderRadius: 6,
        cursor: 'pointer'
      }
    }, "Call it a Draw"))) : /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 22,
        fontWeight: 'bold',
        marginBottom: 12
      }
    }, "Player ", result.winner, " Wins the Match!", result.tiebreak && /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 13,
        fontWeight: 'normal',
        opacity: 0.7
      }
    }, "(by tiebreaker)"))) : /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 20,
        marginBottom: 12
      }
    }, "Final Total: ", p1T, " points across ", matchScores.length, " games"), (!result || !result.tied) && /*#__PURE__*/React.createElement("button", {
      onClick: handleReset,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 18,
        padding: '10px 32px',
        background: '#2a2a2a',
        color: '#fff',
        border: 'none',
        borderRadius: 6,
        cursor: 'pointer',
        letterSpacing: 2
      }
    }, "NEW MATCH"));
  })(), matchPlay && matchPhase === 'sudden-death' && phase === 'gameover' && (() => {
    const p1S = getPlayerFinalScore(players[0], classicMode, laxPlacement);
    const p2S = twoPlayer ? getPlayerFinalScore(players[1], classicMode, laxPlacement) : 0;
    const p1M = p1S >= 100 ? p1S : 0,
      p2M = p2S >= 100 ? p2S : 0;
    if (p1M === p2M) {
      return /*#__PURE__*/React.createElement("div", {
        style: {
          marginTop: 12,
          padding: 16,
          textAlign: 'center',
          background: '#fff3e0',
          border: '1.5px solid #e65100',
          borderRadius: 6
        }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          fontSize: 16,
          fontWeight: 'bold',
          marginBottom: 8
        }
      }, "Still Tied! Play another Sudden Death game."), /*#__PURE__*/React.createElement("div", {
        style: {
          display: 'flex',
          gap: 8,
          justifyContent: 'center'
        }
      }, /*#__PURE__*/React.createElement("button", {
        onClick: resetGameState,
        style: {
          fontFamily: "'Special Elite', 'Courier New', monospace",
          fontSize: 16,
          padding: '8px 24px',
          background: '#c0392b',
          color: '#fff',
          border: 'none',
          borderRadius: 6,
          cursor: 'pointer'
        }
      }, "\u26A1 ANOTHER GAME"), /*#__PURE__*/React.createElement("button", {
        onClick: handleReset,
        style: {
          fontFamily: "'Special Elite', 'Courier New', monospace",
          fontSize: 14,
          padding: '6px 16px',
          background: '#888',
          color: '#fff',
          border: 'none',
          borderRadius: 6,
          cursor: 'pointer'
        }
      }, "Call it a Draw")));
    }
    return /*#__PURE__*/React.createElement("div", {
      style: {
        marginTop: 12,
        padding: 16,
        textAlign: 'center',
        background: '#e8f5e9',
        border: '1.5px solid #27ae60',
        borderRadius: 6
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: 20,
        fontWeight: 'bold',
        marginBottom: 8
      }
    }, "\uD83C\uDFC6 Player ", p1M > p2M ? 1 : 2, " Wins by Sudden Death!"), /*#__PURE__*/React.createElement("button", {
      onClick: handleReset,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 18,
        padding: '10px 32px',
        background: '#2a2a2a',
        color: '#fff',
        border: 'none',
        borderRadius: 6,
        cursor: 'pointer',
        letterSpacing: 2
      }
    }, "NEW MATCH"));
  })(), /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px dashed #ccc',
      marginTop: 12,
      paddingTop: 10,
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
    }
  }, (() => {
    const gameActive = phase !== 'pregame' && phase !== 'gameover';
    return /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex',
        gap: 8,
        alignItems: 'center',
        justifyContent: 'center'
      }
    }, /*#__PURE__*/React.createElement("button", {
      onClick: () => window.open('SIMILI_RULES.pdf', 'simili_rules'),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '4px 0',
        width: 135,
        background: '#fff',
        color: '#888',
        border: '1.5px solid #999',
        borderRadius: 4,
        cursor: 'pointer',
        transition: 'all 0.15s'
      }
    }, "? How to Play"), /*#__PURE__*/React.createElement("button", {
      onClick: () => setShowSettings(prev => !prev),
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '4px 0',
        width: 135,
        background: showSettings ? '#2a2a2a' : '#fff',
        color: showSettings ? '#fff' : '#888',
        border: `1.5px solid ${showSettings ? '#2a2a2a' : '#999'}`,
        borderRadius: 4,
        cursor: 'pointer',
        transition: 'all 0.15s'
      }
    }, "\u2699 Settings"), /*#__PURE__*/React.createElement("button", {
      onClick: gameActive ? () => {
        setPlayers(prev => prev.map(p => ({
          ...p,
          selectedBankIndices: []
        })));
        setAbandoned(true);
        setPhase('gameover');
        setSpinning(false);
        if (matchPlay) {
          setMatchPhase('done');
        }
      } : undefined,
      style: {
        fontFamily: "'Special Elite', 'Courier New', monospace",
        fontSize: 13,
        padding: '4px 0',
        width: 135,
        background: '#fff',
        color: gameActive ? redInk : '#ccc',
        border: `1.5px solid ${gameActive ? redInk : '#ddd'}`,
        borderRadius: 4,
        cursor: gameActive ? 'pointer' : 'default',
        transition: 'all 0.15s',
        opacity: gameActive ? 1 : 0.5
      }
    }, matchPlay ? '✕ Abandon Match' : '✕ Abandon Game'));
  })(), showSettings && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8,
      padding: '12px 16px',
      background: '#faf6ed',
      border: '1px solid #ddd',
      borderRadius: 6,
      width: '100%',
      maxWidth: 400
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      fontWeight: 'bold',
      opacity: 0.5,
      marginBottom: 6,
      textTransform: 'uppercase',
      letterSpacing: 1
    }
  }, "Display"), /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: wideLayout,
    onChange: setWideLayout,
    leftLabel: "Narrow (mobile)",
    rightLabel: "Wide (desktop)"
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: verticalCategories,
    onChange: setVerticalCategories,
    leftLabel: "Side by side",
    rightLabel: "Stacked"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: crossOut,
    onChange: setCrossOut,
    leftLabel: "Strikethrough",
    rightLabel: "Cross Out"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: cellHints,
    onChange: setCellHints,
    leftLabel: "Cell Hints Off",
    rightLabel: "Cell Hints On"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      fontWeight: 'bold',
      opacity: 0.5,
      marginBottom: 6,
      marginTop: 14,
      textTransform: 'uppercase',
      letterSpacing: 1,
      borderTop: '1px dashed #ddd',
      paddingTop: 10
    }
  }, "Gameplay ", phase !== 'pregame' && /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 'normal',
      textTransform: 'none',
      letterSpacing: 0,
      fontStyle: 'italic'
    }
  }, "\u2014 ", matchPlay ? 'start a new match' : 'start a new game', " to change")), /*#__PURE__*/React.createElement("div", {
    style: {
      opacity: phase === 'pregame' ? 1 : 0.4,
      pointerEvents: phase === 'pregame' ? 'auto' : 'none'
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: twoPlayer,
    onChange: setTwoPlayer,
    leftLabel: "1 Player",
    rightLabel: "2 Players"
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: matchPlay,
    onChange: setMatchPlay,
    leftLabel: "Single Game",
    rightLabel: "Match Play"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: classicMode,
    onChange: setClassicMode,
    leftLabel: "Modern Version",
    rightLabel: "Classic Version"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8
    }
  }, /*#__PURE__*/React.createElement(ToggleSwitch, {
    checked: laxPlacement,
    onChange: setLaxPlacement,
    leftLabel: "Strict Placement",
    rightLabel: "Lax Placement"
  })))))));
};
  </script>
  <script>const root = ReactDOM.createRoot(document.getElementById('root'));root.render(React.createElement(window.Simili));</script>
</body>
</html>
